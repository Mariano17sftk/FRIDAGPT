Skip to main contentBusy Beavers!Jim FisherGuide9 chapters37K learnersComing soon1. Uncomputable functionsComing soon2. Interpreters and universality3. The halting problemOr, Turing’s trick to troll any termination test0/244. Proofs about programs0/335. Gödel’s first incompleteness theorem0/26Coming soon6. Godel’s second incompleteness theorem7. Rice’s theorem0/31Coming soon8. Just how busy can a busy beaver be?Coming soon9. Quines and fixed pointsAn easy computation: I want this course.$19. Yours forever. 30-day money-back guarantee.Restart chapterShare chapter0/26Gödel’s first incompleteness theoremAn interactive tutorialWhat is a formal system? 🤵Enumerating theorems ... 🔢Does theorems() do what it says on the tin? 🥫Statements about programs! 👩‍💻Theorem mining — better than crypto?Consistency 👎👍CompletenessA proof using Turing’s theoremWhat about other formal systems?ConclusionSign in (Google/email)AccountWriter’s cornerSend feedbackBy using this site, you agree to our privacy policy.Gödel’s first incompleteness theoremAn interactive tutorialBack in 1931, Kurt Gödel published his first mathematical mic-drop: “Our formal systems of logic can make statements that they can neither prove nor disprove.” In this chapter, you’ll learn what this famous theorem means, and you’ll learn a proof of it that builds upon Turing’s solution to the Halting Problem.Start chapterWhat is a formal system? 🤵Gödel’s theorem is about “formal systems”, but what are they? The standard examples on Wikipedia have weird names like “Zermelo–Fraenkel set theory with the axiom of choice”, and they use fancy math symbols like “∃x,y∈N”. You’d be forgiven for thinking ‘formality’ means black tie.So ... I can take off this tuxedo?Yes, because we’ll instead illustrate the theorem with a dirty, concrete formal system: the Lean proof assistant, a program made by Microsoft Research.Suppose we wanted to say that “for all natural numbers n, 0+n=n”. In Lean, we could write this as(n : Nat) : 0 + n = nYou don’t need to understand the syntax precisely. Just scan over it and notice the 0 + n = n. Now, we could also use Lean to state that “there exists a natural number n, such that n=n+1”. What do you think of this?Such an n existsNo such n existsSo, we need some way to distinguish true statements from false statements! Mathematicians do this using proofs. In Lean, we can prove our first statement with these magic words:theorem zero_add (n : Nat) : 0 + n = n:= by induction n with| zero => rfl| succ n ih => rw [Nat.add_succ, ih]Looks like some dark magic.Don’t sweat the details here! You just need to know that if we run the lean program on this file, it derives the statement that (n : Nat) : 0 + n = n. We can imagine lean as a function that takes a proof string, and either returns null (meaning the proof string is nonsense), or returns the statement string that it proves. Examples:// An accepted proof yields a theoremlean("theorem zero_add ...")  === "(n : Nat) : 0 + n = n";// A nonsense proof proves nothinglean("nonsense") === null;(Note that lean will always halt with either null or a theorem. It just runs the finite list of commands in the proof; it cannot loop forever.)Now let’s see what makes Lean a ‘formal system.’ A formal system has three things:A language to make statements. In Lean, those are things like (n : Nat) : 0 + n = n.A language to make proofs. In Lean, those are things like theorem zero_add ..., which we saw earlier.A way to interpret a proof string as a way to generate a proved statement, which we call a theorem. In the Lean formal system, that’s the program lean.Let’s find more theorems!Enumerating theorems ... 🔢So now the computer can help check our proofs. But finding theorems is still hard work! Can’t we get the computer to prove everything for us? How might we do that?Here’s an idea ... just list out all the possible strings! Every Lean theorem is just a string, so it must be somewhere in the list of all possible strings! Here’s how we can list all strings, in order of increasing length, using a JavaScript generator:// Long list of all Unicode chars!const alphabet = "abc...012...αβγ...";function* strings() {  yield "";  for (const s of strings())    for (const c of alphabet)      yield (s + c);}This generates strings in length order, shortest first: all 0-char strings, then all 1-char strings, then all 2-char strings, and so on. The list looks like this:"", "a", "b", "c", ..., "aa", "ab", ...Will the string "(n : Nat) : 0 + n = n" appear in this list?YesNoBut now we have a problem. For each string in the list, we want to ask whether it’s a theorem. Can we do that by passing it to the lean program?YesNoThe lean program cannot tell us whether a statement is a theorem, because it does not accept statements as input. It accepts proofs as inputs! So instead, we will iterate through all strings, and try to interpret each string as a proof:function* theorems() {  for (const s of strings()) {    const t = lean(s);    if (t !== null) yield t;  }}This procedure theorems() goes through every possible string, and for each, calls lean on it. If lean says the string is a valid proof, it outputs the theorem that it proves.So theorems() lists all the Lean theorems! Cool!Does theorems() do what it says on the tin? 🥫Before we get too excited, let’s distinguish two things:The set of strings outputted by theorems()The set of strings that are Lean theoremsAre these the same sets? Let’s check. First, consider the earlier Lean statement, (n : Nat) : 0 + n = n. Will this statement eventually be found by theorems()?Yes, definitelyMaybe notNext, consider some string x outputted by theorems(). Is it possible that x is not a Lean theorem? Read the source of theorems() to check.Yes, theorems() could output a non-theorem!No, theorems() only outputs theorems.So, we’ve found that theorems() is indeed one and the same as the set of all theorems! Although, here’s one wrinkle ... let’s say we wait around until the theorem  (n : Nat) : 0 + n = n is outputted by theorems(). After that, is it possible that that same theorem could be outputted again?Yes, each theorem could appear many timesNo, each theorem appears onceA theorem will be outputted once for every possible proof of that theorem. But this turns out to be unimportant; we can just de-duplicate these outputs.Right, so the computer can prove everything!Well ... the computer can generate all the Lean theorems. And that’s really cool! In fact, let’s take a moment to see just how cool it is ...This was a preview of chapter 5 of Busy Beavers!. To read all chapters, buy the course for $19. Yours forever.Busy Beavers!An interactive intro to Computability TheoryWhat can computers do? What are the limits of mathematics? And just how busy can a busy beaver be? In this course, you and I will take a practical and modern approach to answering these questions — or at least learning why some questions are unanswerable!The only prerequisite is that you’re comfortable coding. I prefer code like f(x) instead of math squiggles like Fx​. Less γs, more gs. I try to use modern concepts (strings) instead of the original hacks (Gödel numbering). I do examples first; abstraction later. I emphasize real-world languages (mainly JavaScript) rather than Turing Machines and pseudocode.Statements about programs! 👩‍💻Statements like “x+0=x” seem a bit dull. Is Lean limited to arithmetic, or can it tackle more interesting math? In the previous chapter, we learned about the halting problem. That topic is surely mathematics! So can we ‘formalize’ it in Lean?It turns out, yes! We can teach Lean a simple language called the Turing Machine, and teach it how to run one. Then we can talk about whether a Turing Machine machine eventually halts. And here it is: a Lean (v3) proof of Turing’s theorem!:theorem halting_problem (n) :  ¬ computable_pred (λ c, (eval c n).dom)  | h :=  rice {f | (f n).dom} h nat.partrec.zero  nat.partrec.none trivialSo Lean can prove that the halting problem is undecidable. But if you run theorems(), will it discover this theorem?YesNoAnd not only that: theorems() will find the shortest proof. Perhaps it’s much more elegant than the one we humans found. So, theorems() really is amazing! Let’s try it out, and see if we can win ourselves a mathematical prize!ContinueTheorem mining — better than crypto?Instead of just listing out all theorems, let’s say we’re just interested in one particular mathematical claim, and we want to know whether it’s true. Consider the following famous function:function collatz(n: number) {  while (n != 1) {    if (n % 2 == 0) n = n / 2;    else n = 3*n + 1;  }}Try it out! Does collatz(3) halt?YesNoOkay, now what about for any starting number? In 1937, Herr Collatz himself conjectured: “collatz(n) always halts, for every natural number n.” What do you think of this claim?True!False!Neither true nor false!I don’t know!There’s a $1M prize for proving the truth or non-truth of this famous conjecture. So let’s deploy our amazing function theorems() to earn some easy money! First, we write the conjecture in Lean:import Init.Data.Nat.Basicdef step (n: Nat): Nat :=  if n%2 == 0 then n/2 else 3*n + 1def coll_conj :=  ∀n, n>0 -> ∃s,    Nat.repeat step s n = 1Then we search through theorems() to see whether there’s a proof:const coll_conj = "...";function is_collatz_true() {  for (const t of theorems()) {    if (t === coll_conj) {      // Proof found! It must be true!      return true;    }  }  // No proof found! It must be false!  return false;}Here’s how it should work: if the conjecture is true, is_collatz_true should return true, and if the conjecture is false, is_collatz_true should return false.Now, imagine that the Collatz conjecture is false. Read the source: what does is_collatz_true do in this case?Return trueReturn falseLoop foreverThe problem is that we never actually search for a proof that the conjecture is false; we only search for a proof that it’s true!In Lean, the word ‘not’ is written as ¬. So the inverse of the conjecture is ¬coll_conj. So let’s just add that to our search!function is_stmt_true(s: string) {  for (const t of theorems()) {    if (t == s) return true;    if (t == "¬"+s) return false;  }}function is_collatz_true() {  return is_stmt_true(coll_conj);}This is looking better! We have an amazing function, is_stmt_true, that can tell us whether anything is true or false, given enough time!Read it through, and try to prove to yourself that is_collatz_true really does eventually return the truth of the Collatz conjecture.Okay, I tried to prove it ...Eventually, I think you’ll realize the algorithm relies on this assumption:  “theorems() contains either coll_conj or ¬coll_conj. It does not contain both, or neither.”This assumption is quite natural. We’ve already accepted that the Collatz conjecture is either true or false. So, similarly, theorems() should contain either coll_conj or ¬coll_conj. This gets to the heart of what Godel wanted to prove.Consistency 👎👍But what if theorems() contains both coll_conj and ¬coll_conj? Is that possible?YesNoI don’t knowThis property is known as consistency. Lean is ‘consistent’ if there are no statements S where both S and ¬S are theorems.Recall the ‘proof by contradiction’ method that we used in Chapter 1 to prove Turing’s theorem. The idea is that, if an assumption leads to a contradiction, the assumption must be false. The Lean system lets you use this proof method to generate theorems.Now, imagine that both coll_conj and ¬coll_conj are both theorems. Could we prove that 1+1=3 in Lean?YesNoI don’t knowWorse, we could use this method to prove anything in Lean! So, inconsistency would be disastrous. Mathematicians generally assume that their systems are consistent. (But it turns out to be rather hard to show it! We’ll see why in a future chapter!)ContinueCompletenessThis leaves one final possibility. What if theorems() contains neither coll_conj nor ¬coll_conj? How disastrous would that be? Could you use that to prove that 1+1=3 in Lean?YesNoI don’t knowIn general, the absence of a proof doesn’t lead to a complete collapse. It would just mean that Lean is not powerful enough to comment on the truth of the statement.However, it would still be extremely nice if Lean were able to say, one way or another, whether the Collatz conjecture is true. And it would be even nicer if Lean were able to say, one way or the other, whether any statement is true.If this were the case, we would say that Lean is complete. Precisely: if Lean is complete, then we can make any statement S, and either S or ¬S is in theorems().So, earlier when we tried to prove that is_stmt_true is a correct algorithm, we relied on the assumption that Lean is both consistent and complete.Okay, so, is that assumption true?A proof using Turing’s theoremSo, is Lean consistent and complete? Here’s Gödel’s famous answer: No, Lean is either inconsistent or incomplete!Our proof works by way of contradiction. The assumption: Lean is consistent and complete. We decided earlier that, if this is true, then our is_stmt_true function works perfectly.Now, recall the Halting Problem from the previous chapter. This problem asks for a function halts(tm) that returns true or false telling us whether the Turing Machine tm halts. With our is_stmt_true function, we can easily solve the Halting Problem!:function halts(tm: string) {  const lean_stmt = `halts ${tm}`;  return is_stmt_true(lean_stmt);}We saw earlier that Lean can talk about whether Turing Machines halt. So we can construct a Lean statement claiming that the Turing Machine tm halts. Then we just ... ask whether that statement is true!Easy! But hang on ...Yes! We also learned in Chapter 1 that the Halting Problem is impossible to solve! So we got a contradiction!The problem must be our initial assumption, that “Lean is consistent and complete.” We can therefore conclude that Lean is either inconsistent or incomplete!Okay, that’s Lean. What about other systems?What about other formal systems?In this chapter, we applied this reasoning to Lean, one specific formal system. But the same reasoning can be applied to any formal system F, with fairly minimal assumptions:1. F is enumerable. (This comes for free via the theorems trick.)2. We can reason about programs and halting in F.Gödel’s original proof was slightly stronger: it only required that F can reason about arithmetic, rather than programs and halting. But it turns out that pretty much any formal system can reason about programs — we’ll learn how easily in a future chapter!ConclusionYou might be wondering ... Okay, perhaps we can’t show that our systems of logic are complete, but perhaps we can at least show that they are consistent. But Gödel has some more bad news for you, coming up in the next chapter ...Finish chapter! 🥸If you want to know when the next chapter comes out, sign up for updates here! You might also enjoy our course Everyday Data Science, which teaches fundamental data science using the same interactive format.Next in Busy Beavers!:Coming soon6. Godel’s second incompleteness theoremNot satisfied with one bombshell, Kurt quickly arrived at a second. So what if there are things our systems can’t prove? Perhaps those things are unimportant anyway. Well, Kurt’s second theorem finds a very important thing that these systems can’t prove: their own consistency!In this chapter, we will learn why our systems, if they are consistent, cannot prove their own consistency. This builds neatly on top of the first theorem.You’re previewing chapter 5 of Busy Beavers!. Get all 9 chapters forever for $19.Quoted text: Send feedback 📩Your feedback will be sent privately to the author. They may reply to you by email. Thanks for helping make this course better!Gödel’s first incompleteness theorem | Busy Beavers!window.dataLayer = window.dataLayer || [];        function gtag(){dataLayer.push(arguments);}        gtag('js', new Date());        gtag('config', 'G-J286F3WJVC');.qJTHM{-webkit-user-select:none;color:#202124;direction:ltr;-webkit-touch-callout:none;font-family:"Roboto-Regular",arial,sans-serif;-webkit-font-smoothing:antialiased;font-weight:400;margin:0;overflow:hidden;-webkit-text-size-adjust:100%}.ynRLnc{left:-9999px;position:absolute;top:-9999px}.L6cTce{display:none}.bltWBb{word-break:break-all}.hSRGPd{color:#1a73e8;cursor:pointer;font-weight:500;text-decoration:none}.Bz112c-W3lGp{height:16px;width:16px}.Bz112c-E3DyYd{height:20px;width:20px}.Bz112c-r9oPif{height:24px;width:24px}.Bz112c-uaxL4e{-webkit-border-radius:10px;border-radius:10px}.LgbsSe-Bz112c{display:block}.S9gUrf-YoZ4jf,.S9gUrf-YoZ4jf *{border:none;margin:0;padding:0}.fFW7wc-ibnC6b>.aZ2wEe>div{border-color:#4285f4}.P1ekSe-ZMv3u>div:nth-child(1){background-color:#1a73e8!important}.P1ekSe-ZMv3u>div:nth-child(2),.P1ekSe-ZMv3u>div:nth-child(3){background-image:linear-gradient(to right,rgba(255,255,255,.7),rgba(255,255,255,.7)),linear-gradient(to right,#1a73e8,#1a73e8)!important}.haAclf{display:inline-block}.nsm7Bb-HzV7m-LgbsSe{-webkit-border-radius:4px;border-radius:4px;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-transition:background-color .218s,border-color .218s;transition:background-color .218s,border-color .218s;-webkit-user-select:none;-webkit-appearance:none;background-color:#fff;background-image:none;border:1px solid #dadce0;color:#3c4043;cursor:pointer;font-family:"Google Sans",arial,sans-serif;font-size:14px;height:40px;letter-spacing:0.25px;outline:none;overflow:hidden;padding:0 12px;position:relative;text-align:center;vertical-align:middle;white-space:nowrap;width:auto}@media screen and (-ms-high-contrast:active){.nsm7Bb-HzV7m-LgbsSe{border:2px solid windowText;color:windowText}}.nsm7Bb-HzV7m-LgbsSe.pSzOP-SxQuSe{font-size:14px;height:32px;letter-spacing:0.25px;padding:0 10px}.nsm7Bb-HzV7m-LgbsSe.purZT-SxQuSe{font-size:11px;height:20px;letter-spacing:0.3px;padding:0 8px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe{padding:0;width:40px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe.pSzOP-SxQuSe{width:32px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe.purZT-SxQuSe{width:20px}.nsm7Bb-HzV7m-LgbsSe.JGcpL-RbRzK{-webkit-border-radius:20px;border-radius:20px}.nsm7Bb-HzV7m-LgbsSe.JGcpL-RbRzK.pSzOP-SxQuSe{-webkit-border-radius:16px;border-radius:16px}.nsm7Bb-HzV7m-LgbsSe.JGcpL-RbRzK.purZT-SxQuSe{-webkit-border-radius:10px;border-radius:10px}.nsm7Bb-HzV7m-LgbsSe.MFS4be-Ia7Qfc{border:none;color:#fff}.nsm7Bb-HzV7m-LgbsSe.MFS4be-v3pZbf-Ia7Qfc{background-color:#1a73e8}.nsm7Bb-HzV7m-LgbsSe.MFS4be-JaPV2b-Ia7Qfc{background-color:#202124;color:#e8eaed}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{height:18px;margin-right:8px;min-width:18px;width:18px}.nsm7Bb-HzV7m-LgbsSe.pSzOP-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{height:14px;min-width:14px;width:14px}.nsm7Bb-HzV7m-LgbsSe.purZT-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{height:10px;min-width:10px;width:10px}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-Bz112c{margin-left:8px;margin-right:-4px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{margin:0;padding:10px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe.pSzOP-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{padding:8px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe.purZT-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{padding:4px}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{-webkit-border-top-left-radius:3px;border-top-left-radius:3px;-webkit-border-bottom-left-radius:3px;border-bottom-left-radius:3px;display:-webkit-box;display:-webkit-flex;display:flex;justify-content:center;-webkit-align-items:center;align-items:center;background-color:#fff;height:36px;margin-left:-10px;margin-right:12px;min-width:36px;width:36px}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf .nsm7Bb-HzV7m-LgbsSe-Bz112c,.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf .nsm7Bb-HzV7m-LgbsSe-Bz112c{margin:0;padding:0}.nsm7Bb-HzV7m-LgbsSe.pSzOP-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{height:28px;margin-left:-8px;margin-right:10px;min-width:28px;width:28px}.nsm7Bb-HzV7m-LgbsSe.purZT-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{height:16px;margin-left:-6px;margin-right:8px;min-width:16px;width:16px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{-webkit-border-radius:3px;border-radius:3px;margin-left:2px;margin-right:0;padding:0}.nsm7Bb-HzV7m-LgbsSe.JGcpL-RbRzK .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{-webkit-border-radius:18px;border-radius:18px}.nsm7Bb-HzV7m-LgbsSe.pSzOP-SxQuSe.JGcpL-RbRzK .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{-webkit-border-radius:14px;border-radius:14px}.nsm7Bb-HzV7m-LgbsSe.purZT-SxQuSe.JGcpL-RbRzK .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{-webkit-border-radius:8px;border-radius:8px}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-bN97Pc-sM5MNb{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-align-items:center;align-items:center;-webkit-flex-direction:row;flex-direction:row;justify-content:space-between;-webkit-flex-wrap:nowrap;flex-wrap:nowrap;height:100%;position:relative;width:100%}.nsm7Bb-HzV7m-LgbsSe .oXtfBe-l4eHX{justify-content:center}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-BPrWId{-webkit-flex-grow:1;flex-grow:1;font-family:"Google Sans",arial,sans-serif;font-weight:500;overflow:hidden;text-overflow:ellipsis;vertical-align:top}.nsm7Bb-HzV7m-LgbsSe.purZT-SxQuSe .nsm7Bb-HzV7m-LgbsSe-BPrWId{font-weight:300}.nsm7Bb-HzV7m-LgbsSe .oXtfBe-l4eHX .nsm7Bb-HzV7m-LgbsSe-BPrWId{-webkit-flex-grow:0;flex-grow:0}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-MJoBVe{-webkit-transition:background-color .218s;transition:background-color .218s;bottom:0;left:0;position:absolute;right:0;top:0}.nsm7Bb-HzV7m-LgbsSe:hover,.nsm7Bb-HzV7m-LgbsSe:focus{-webkit-box-shadow:none;box-shadow:none;border-color:#d2e3fc;outline:none}.nsm7Bb-HzV7m-LgbsSe:hover .nsm7Bb-HzV7m-LgbsSe-MJoBVe,.nsm7Bb-HzV7m-LgbsSe:focus .nsm7Bb-HzV7m-LgbsSe-MJoBVe{background:rgba(66,133,244,.04)}.nsm7Bb-HzV7m-LgbsSe:active .nsm7Bb-HzV7m-LgbsSe-MJoBVe{background:rgba(66,133,244,.1)}.nsm7Bb-HzV7m-LgbsSe.MFS4be-Ia7Qfc:hover .nsm7Bb-HzV7m-LgbsSe-MJoBVe,.nsm7Bb-HzV7m-LgbsSe.MFS4be-Ia7Qfc:focus .nsm7Bb-HzV7m-LgbsSe-MJoBVe{background:rgba(255,255,255,.24)}.nsm7Bb-HzV7m-LgbsSe.MFS4be-Ia7Qfc:active .nsm7Bb-HzV7m-LgbsSe-MJoBVe{background:rgba(255,255,255,.32)}.nsm7Bb-HzV7m-LgbsSe .n1UuX-DkfjY{-webkit-border-radius:50%;border-radius:50%;display:-webkit-box;display:-webkit-flex;display:flex;height:20px;margin-left:-4px;margin-right:8px;min-width:20px;width:20px}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-BPrWId{font-family:"Roboto";font-size:12px;text-align:left}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-BPrWId .ssJRIf,.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-BPrWId .K4efff .fmcmS{overflow:hidden;text-overflow:ellipsis}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-BPrWId .K4efff{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-align-items:center;align-items:center;color:#5f6368;fill:#5f6368;font-size:11px;font-weight:400}.nsm7Bb-HzV7m-LgbsSe.jVeSEe.MFS4be-Ia7Qfc .nsm7Bb-HzV7m-LgbsSe-BPrWId .K4efff{color:#e8eaed;fill:#e8eaed}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-BPrWId .K4efff .Bz112c{height:18px;margin:-3px -3px -3px 2px;min-width:18px;width:18px}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{-webkit-border-top-left-radius:0;border-top-left-radius:0;-webkit-border-bottom-left-radius:0;border-bottom-left-radius:0;-webkit-border-top-right-radius:3px;border-top-right-radius:3px;-webkit-border-bottom-right-radius:3px;border-bottom-right-radius:3px;margin-left:12px;margin-right:-10px}.nsm7Bb-HzV7m-LgbsSe.jVeSEe.JGcpL-RbRzK .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{-webkit-border-radius:18px;border-radius:18px}.L5Fo6c-sM5MNb{border:0;display:block;left:0;position:relative;top:0}.L5Fo6c-bF1uUb{-webkit-border-radius:4px;border-radius:4px;bottom:0;cursor:pointer;left:0;position:absolute;right:0;top:0}.L5Fo6c-bF1uUb:focus{border:none;outline:none}sentinel{}Gödel’s first incompleteness theorem | Busy Beavers!window.dataLayer = window.dataLayer || [];        function gtag(){dataLayer.push(arguments);}        gtag('js', new Date());        gtag('config', 'G-J286F3WJVC');.qJTHM{-webkit-user-select:none;color:#202124;direction:ltr;-webkit-touch-callout:none;font-family:"Roboto-Regular",arial,sans-serif;-webkit-font-smoothing:antialiased;font-weight:400;margin:0;overflow:hidden;-webkit-text-size-adjust:100%}.ynRLnc{left:-9999px;position:absolute;top:-9999px}.L6cTce{display:none}.bltWBb{word-break:break-all}.hSRGPd{color:#1a73e8;cursor:pointer;font-weight:500;text-decoration:none}.Bz112c-W3lGp{height:16px;width:16px}.Bz112c-E3DyYd{height:20px;width:20px}.Bz112c-r9oPif{height:24px;width:24px}.Bz112c-uaxL4e{-webkit-border-radius:10px;border-radius:10px}.LgbsSe-Bz112c{display:block}.S9gUrf-YoZ4jf,.S9gUrf-YoZ4jf *{border:none;margin:0;padding:0}.fFW7wc-ibnC6b>.aZ2wEe>div{border-color:#4285f4}.P1ekSe-ZMv3u>div:nth-child(1){background-color:#1a73e8!important}.P1ekSe-ZMv3u>div:nth-child(2),.P1ekSe-ZMv3u>div:nth-child(3){background-image:linear-gradient(to right,rgba(255,255,255,.7),rgba(255,255,255,.7)),linear-gradient(to right,#1a73e8,#1a73e8)!important}.haAclf{display:inline-block}.nsm7Bb-HzV7m-LgbsSe{-webkit-border-radius:4px;border-radius:4px;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-transition:background-color .218s,border-color .218s;transition:background-color .218s,border-color .218s;-webkit-user-select:none;-webkit-appearance:none;background-color:#fff;background-image:none;border:1px solid #dadce0;color:#3c4043;cursor:pointer;font-family:"Google Sans",arial,sans-serif;font-size:14px;height:40px;letter-spacing:0.25px;outline:none;overflow:hidden;padding:0 12px;position:relative;text-align:center;vertical-align:middle;white-space:nowrap;width:auto}@media screen and (-ms-high-contrast:active){.nsm7Bb-HzV7m-LgbsSe{border:2px solid windowText;color:windowText}}.nsm7Bb-HzV7m-LgbsSe.pSzOP-SxQuSe{font-size:14px;height:32px;letter-spacing:0.25px;padding:0 10px}.nsm7Bb-HzV7m-LgbsSe.purZT-SxQuSe{font-size:11px;height:20px;letter-spacing:0.3px;padding:0 8px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe{padding:0;width:40px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe.pSzOP-SxQuSe{width:32px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe.purZT-SxQuSe{width:20px}.nsm7Bb-HzV7m-LgbsSe.JGcpL-RbRzK{-webkit-border-radius:20px;border-radius:20px}.nsm7Bb-HzV7m-LgbsSe.JGcpL-RbRzK.pSzOP-SxQuSe{-webkit-border-radius:16px;border-radius:16px}.nsm7Bb-HzV7m-LgbsSe.JGcpL-RbRzK.purZT-SxQuSe{-webkit-border-radius:10px;border-radius:10px}.nsm7Bb-HzV7m-LgbsSe.MFS4be-Ia7Qfc{border:none;color:#fff}.nsm7Bb-HzV7m-LgbsSe.MFS4be-v3pZbf-Ia7Qfc{background-color:#1a73e8}.nsm7Bb-HzV7m-LgbsSe.MFS4be-JaPV2b-Ia7Qfc{background-color:#202124;color:#e8eaed}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{height:18px;margin-right:8px;min-width:18px;width:18px}.nsm7Bb-HzV7m-LgbsSe.pSzOP-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{height:14px;min-width:14px;width:14px}.nsm7Bb-HzV7m-LgbsSe.purZT-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{height:10px;min-width:10px;width:10px}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-Bz112c{margin-left:8px;margin-right:-4px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{margin:0;padding:10px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe.pSzOP-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{padding:8px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe.purZT-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{padding:4px}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{-webkit-border-top-left-radius:3px;border-top-left-radius:3px;-webkit-border-bottom-left-radius:3px;border-bottom-left-radius:3px;display:-webkit-box;display:-webkit-flex;display:flex;justify-content:center;-webkit-align-items:center;align-items:center;background-color:#fff;height:36px;margin-left:-10px;margin-right:12px;min-width:36px;width:36px}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf .nsm7Bb-HzV7m-LgbsSe-Bz112c,.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf .nsm7Bb-HzV7m-LgbsSe-Bz112c{margin:0;padding:0}.nsm7Bb-HzV7m-LgbsSe.pSzOP-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{height:28px;margin-left:-8px;margin-right:10px;min-width:28px;width:28px}.nsm7Bb-HzV7m-LgbsSe.purZT-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{height:16px;margin-left:-6px;margin-right:8px;min-width:16px;width:16px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{-webkit-border-radius:3px;border-radius:3px;margin-left:2px;margin-right:0;padding:0}.nsm7Bb-HzV7m-LgbsSe.JGcpL-RbRzK .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{-webkit-border-radius:18px;border-radius:18px}.nsm7Bb-HzV7m-LgbsSe.pSzOP-SxQuSe.JGcpL-RbRzK .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{-webkit-border-radius:14px;border-radius:14px}.nsm7Bb-HzV7m-LgbsSe.purZT-SxQuSe.JGcpL-RbRzK .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{-webkit-border-radius:8px;border-radius:8px}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-bN97Pc-sM5MNb{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-align-items:center;align-items:center;-webkit-flex-direction:row;flex-direction:row;justify-content:space-between;-webkit-flex-wrap:nowrap;flex-wrap:nowrap;height:100%;position:relative;width:100%}.nsm7Bb-HzV7m-LgbsSe .oXtfBe-l4eHX{justify-content:center}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-BPrWId{-webkit-flex-grow:1;flex-grow:1;font-family:"Google Sans",arial,sans-serif;font-weight:500;overflow:hidden;text-overflow:ellipsis;vertical-align:top}.nsm7Bb-HzV7m-LgbsSe.purZT-SxQuSe .nsm7Bb-HzV7m-LgbsSe-BPrWId{font-weight:300}.nsm7Bb-HzV7m-LgbsSe .oXtfBe-l4eHX .nsm7Bb-HzV7m-LgbsSe-BPrWId{-webkit-flex-grow:0;flex-grow:0}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-MJoBVe{-webkit-transition:background-color .218s;transition:background-color .218s;bottom:0;left:0;position:absolute;right:0;top:0}.nsm7Bb-HzV7m-LgbsSe:hover,.nsm7Bb-HzV7m-LgbsSe:focus{-webkit-box-shadow:none;box-shadow:none;border-color:#d2e3fc;outline:none}.nsm7Bb-HzV7m-LgbsSe:hover .nsm7Bb-HzV7m-LgbsSe-MJoBVe,.nsm7Bb-HzV7m-LgbsSe:focus .nsm7Bb-HzV7m-LgbsSe-MJoBVe{background:rgba(66,133,244,.04)}.nsm7Bb-HzV7m-LgbsSe:active .nsm7Bb-HzV7m-LgbsSe-MJoBVe{background:rgba(66,133,244,.1)}.nsm7Bb-HzV7m-LgbsSe.MFS4be-Ia7Qfc:hover .nsm7Bb-HzV7m-LgbsSe-MJoBVe,.nsm7Bb-HzV7m-LgbsSe.MFS4be-Ia7Qfc:focus .nsm7Bb-HzV7m-LgbsSe-MJoBVe{background:rgba(255,255,255,.24)}.nsm7Bb-HzV7m-LgbsSe.MFS4be-Ia7Qfc:active .nsm7Bb-HzV7m-LgbsSe-MJoBVe{background:rgba(255,255,255,.32)}.nsm7Bb-HzV7m-LgbsSe .n1UuX-DkfjY{-webkit-border-radius:50%;border-radius:50%;display:-webkit-box;display:-webkit-flex;display:flex;height:20px;margin-left:-4px;margin-right:8px;min-width:20px;width:20px}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-BPrWId{font-family:"Roboto";font-size:12px;text-align:left}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-BPrWId .ssJRIf,.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-BPrWId .K4efff .fmcmS{overflow:hidden;text-overflow:ellipsis}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-BPrWId .K4efff{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-align-items:center;align-items:center;color:#5f6368;fill:#5f6368;font-size:11px;font-weight:400}.nsm7Bb-HzV7m-LgbsSe.jVeSEe.MFS4be-Ia7Qfc .nsm7Bb-HzV7m-LgbsSe-BPrWId .K4efff{color:#e8eaed;fill:#e8eaed}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-BPrWId .K4efff .Bz112c{height:18px;margin:-3px -3px -3px 2px;min-width:18px;width:18px}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{-webkit-border-top-left-radius:0;border-top-left-radius:0;-webkit-border-bottom-left-radius:0;border-bottom-left-radius:0;-webkit-border-top-right-radius:3px;border-top-right-radius:3px;-webkit-border-bottom-right-radius:3px;border-bottom-right-radius:3px;margin-left:12px;margin-right:-10px}.nsm7Bb-HzV7m-LgbsSe.jVeSEe.JGcpL-RbRzK .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{-webkit-border-radius:18px;border-radius:18px}.L5Fo6c-sM5MNb{border:0;display:block;left:0;position:relative;top:0}.L5Fo6c-bF1uUb{-webkit-border-radius:4px;border-radius:4px;bottom:0;cursor:pointer;left:0;position:absolute;right:0;top:0}.L5Fo6c-bF1uUb:focus{border:none;outline:none}sentinel{}Sign inSkip to main contentBusy Beavers!Jim FisherGuide9 chapters37K learnersComing soon1. Uncomputable functionsComing soon2. Interpreters and universality3. The halting problemOr, Turing’s trick to troll any termination test0/244. Proofs about programs0/335. Gödel’s first incompleteness theorem0/26Coming soon6. Godel’s second incompleteness theorem7. Rice’s theorem0/31Coming soon8. Just how busy can a busy beaver be?Coming soon9. Quines and fixed pointsAn easy computation: I want this course.$19. Yours forever. 30-day money-back guarantee.Restart chapterShare chapter0/26Gödel’s first incompleteness theoremAn interactive tutorialWhat is a formal system? 🤵Enumerating theorems ... 🔢Does theorems() do what it says on the tin? 🥫Statements about programs! 👩‍💻Theorem mining — better than crypto?Consistency 👎👍CompletenessA proof using Turing’s theoremWhat about other formal systems?ConclusionSign in (Google/email)AccountWriter’s cornerSend feedbackBy using this site, you agree to our privacy policy.Skip to main contentBusy Beavers!Jim FisherGuide9 chapters37K learnersComing soon1. Uncomputable functionsComing soon2. Interpreters and universality3. The halting problemOr, Turing’s trick to troll any termination test0/244. Proofs about programs0/335. Gödel’s first incompleteness theorem0/26Coming soon6. Godel’s second incompleteness theorem7. Rice’s theorem0/31Coming soon8. Just how busy can a busy beaver be?Coming soon9. Quines and fixed pointsAn easy computation: I want this course.$19. Yours forever. 30-day money-back guarantee.Restart chapterShare chapterBusy Beavers!Jim FisherGuide9 chapters37K learnersComing soon1. Uncomputable functionsComing soon2. Interpreters and universality3. The halting problemOr, Turing’s trick to troll any termination test0/244. Proofs about programs0/335. Gödel’s first incompleteness theorem0/26Coming soon6. Godel’s second incompleteness theorem7. Rice’s theorem0/31Coming soon8. Just how busy can a busy beaver be?Coming soon9. Quines and fixed pointsAn easy computation: I want this course.$19. Yours forever. 30-day money-back guarantee.Busy Beavers!Jim FisherGuide9 chapters37K learnersJim FisherGuideGuide9 chapters37K learners9 chapters37K learnersComing soon1. Uncomputable functionsComing soon1. Uncomputable functionsComing soon2. Interpreters and universality2. Interpreters and universality3. The halting problemOr, Turing’s trick to troll any termination test0/243. The halting problemOr, Turing’s trick to troll any termination test3. The halting problemOr, Turing’s trick to troll any termination test0/244. Proofs about programs0/334. Proofs about programs0/335. Gödel’s first incompleteness theorem0/265. Gödel’s first incompleteness theorem0/26Coming soon6. Godel’s second incompleteness theorem6. Godel’s second incompleteness theorem7. Rice’s theorem0/317. Rice’s theorem0/31Coming soon8. Just how busy can a busy beaver be?8. Just how busy can a busy beaver be?Coming soon9. Quines and fixed points9. Quines and fixed pointsAn easy computation: I want this course.$19. Yours forever. 30-day money-back guarantee.An easy computation: I want this course.$19. Yours forever. 30-day money-back guarantee.Restart chapterShare chapter0/26Gödel’s first incompleteness theoremAn interactive tutorialWhat is a formal system? 🤵Enumerating theorems ... 🔢Does theorems() do what it says on the tin? 🥫Statements about programs! 👩‍💻Theorem mining — better than crypto?Consistency 👎👍CompletenessA proof using Turing’s theoremWhat about other formal systems?ConclusionGödel’s first incompleteness theoremAn interactive tutorialWhat is a formal system? 🤵Enumerating theorems ... 🔢Does theorems() do what it says on the tin? 🥫Statements about programs! 👩‍💻Theorem mining — better than crypto?Consistency 👎👍CompletenessA proof using Turing’s theoremWhat about other formal systems?ConclusionGödel’s first incompleteness theoremAn interactive tutorialWhat is a formal system? 🤵Enumerating theorems ... 🔢Does theorems() do what it says on the tin? 🥫theorems()Statements about programs! 👩‍💻Theorem mining — better than crypto?Consistency 👎👍CompletenessA proof using Turing’s theoremWhat about other formal systems?ConclusionSign in (Google/email)AccountWriter’s cornerSend feedbackBy using this site, you agree to our privacy policy.Sign in (Google/email)AccountWriter’s cornerSend feedbackBy using this site, you agree to our privacy policy.our privacy policyGödel’s first incompleteness theoremAn interactive tutorialBack in 1931, Kurt Gödel published his first mathematical mic-drop: “Our formal systems of logic can make statements that they can neither prove nor disprove.” In this chapter, you’ll learn what this famous theorem means, and you’ll learn a proof of it that builds upon Turing’s solution to the Halting Problem.Start chapterWhat is a formal system? 🤵Gödel’s theorem is about “formal systems”, but what are they? The standard examples on Wikipedia have weird names like “Zermelo–Fraenkel set theory with the axiom of choice”, and they use fancy math symbols like “∃x,y∈N”. You’d be forgiven for thinking ‘formality’ means black tie.So ... I can take off this tuxedo?Yes, because we’ll instead illustrate the theorem with a dirty, concrete formal system: the Lean proof assistant, a program made by Microsoft Research.Suppose we wanted to say that “for all natural numbers n, 0+n=n”. In Lean, we could write this as(n : Nat) : 0 + n = nYou don’t need to understand the syntax precisely. Just scan over it and notice the 0 + n = n. Now, we could also use Lean to state that “there exists a natural number n, such that n=n+1”. What do you think of this?Such an n existsNo such n existsSo, we need some way to distinguish true statements from false statements! Mathematicians do this using proofs. In Lean, we can prove our first statement with these magic words:theorem zero_add (n : Nat) : 0 + n = n:= by induction n with| zero => rfl| succ n ih => rw [Nat.add_succ, ih]Looks like some dark magic.Don’t sweat the details here! You just need to know that if we run the lean program on this file, it derives the statement that (n : Nat) : 0 + n = n. We can imagine lean as a function that takes a proof string, and either returns null (meaning the proof string is nonsense), or returns the statement string that it proves. Examples:// An accepted proof yields a theoremlean("theorem zero_add ...")  === "(n : Nat) : 0 + n = n";// A nonsense proof proves nothinglean("nonsense") === null;(Note that lean will always halt with either null or a theorem. It just runs the finite list of commands in the proof; it cannot loop forever.)Now let’s see what makes Lean a ‘formal system.’ A formal system has three things:A language to make statements. In Lean, those are things like (n : Nat) : 0 + n = n.A language to make proofs. In Lean, those are things like theorem zero_add ..., which we saw earlier.A way to interpret a proof string as a way to generate a proved statement, which we call a theorem. In the Lean formal system, that’s the program lean.Let’s find more theorems!Enumerating theorems ... 🔢So now the computer can help check our proofs. But finding theorems is still hard work! Can’t we get the computer to prove everything for us? How might we do that?Here’s an idea ... just list out all the possible strings! Every Lean theorem is just a string, so it must be somewhere in the list of all possible strings! Here’s how we can list all strings, in order of increasing length, using a JavaScript generator:// Long list of all Unicode chars!const alphabet = "abc...012...αβγ...";function* strings() {  yield "";  for (const s of strings())    for (const c of alphabet)      yield (s + c);}This generates strings in length order, shortest first: all 0-char strings, then all 1-char strings, then all 2-char strings, and so on. The list looks like this:"", "a", "b", "c", ..., "aa", "ab", ...Will the string "(n : Nat) : 0 + n = n" appear in this list?YesNoBut now we have a problem. For each string in the list, we want to ask whether it’s a theorem. Can we do that by passing it to the lean program?YesNoThe lean program cannot tell us whether a statement is a theorem, because it does not accept statements as input. It accepts proofs as inputs! So instead, we will iterate through all strings, and try to interpret each string as a proof:function* theorems() {  for (const s of strings()) {    const t = lean(s);    if (t !== null) yield t;  }}This procedure theorems() goes through every possible string, and for each, calls lean on it. If lean says the string is a valid proof, it outputs the theorem that it proves.So theorems() lists all the Lean theorems! Cool!Does theorems() do what it says on the tin? 🥫Before we get too excited, let’s distinguish two things:The set of strings outputted by theorems()The set of strings that are Lean theoremsAre these the same sets? Let’s check. First, consider the earlier Lean statement, (n : Nat) : 0 + n = n. Will this statement eventually be found by theorems()?Yes, definitelyMaybe notNext, consider some string x outputted by theorems(). Is it possible that x is not a Lean theorem? Read the source of theorems() to check.Yes, theorems() could output a non-theorem!No, theorems() only outputs theorems.So, we’ve found that theorems() is indeed one and the same as the set of all theorems! Although, here’s one wrinkle ... let’s say we wait around until the theorem  (n : Nat) : 0 + n = n is outputted by theorems(). After that, is it possible that that same theorem could be outputted again?Yes, each theorem could appear many timesNo, each theorem appears onceA theorem will be outputted once for every possible proof of that theorem. But this turns out to be unimportant; we can just de-duplicate these outputs.Right, so the computer can prove everything!Well ... the computer can generate all the Lean theorems. And that’s really cool! In fact, let’s take a moment to see just how cool it is ...This was a preview of chapter 5 of Busy Beavers!. To read all chapters, buy the course for $19. Yours forever.Busy Beavers!An interactive intro to Computability TheoryWhat can computers do? What are the limits of mathematics? And just how busy can a busy beaver be? In this course, you and I will take a practical and modern approach to answering these questions — or at least learning why some questions are unanswerable!The only prerequisite is that you’re comfortable coding. I prefer code like f(x) instead of math squiggles like Fx​. Less γs, more gs. I try to use modern concepts (strings) instead of the original hacks (Gödel numbering). I do examples first; abstraction later. I emphasize real-world languages (mainly JavaScript) rather than Turing Machines and pseudocode.Statements about programs! 👩‍💻Statements like “x+0=x” seem a bit dull. Is Lean limited to arithmetic, or can it tackle more interesting math? In the previous chapter, we learned about the halting problem. That topic is surely mathematics! So can we ‘formalize’ it in Lean?It turns out, yes! We can teach Lean a simple language called the Turing Machine, and teach it how to run one. Then we can talk about whether a Turing Machine machine eventually halts. And here it is: a Lean (v3) proof of Turing’s theorem!:theorem halting_problem (n) :  ¬ computable_pred (λ c, (eval c n).dom)  | h :=  rice {f | (f n).dom} h nat.partrec.zero  nat.partrec.none trivialSo Lean can prove that the halting problem is undecidable. But if you run theorems(), will it discover this theorem?YesNoAnd not only that: theorems() will find the shortest proof. Perhaps it’s much more elegant than the one we humans found. So, theorems() really is amazing! Let’s try it out, and see if we can win ourselves a mathematical prize!ContinueTheorem mining — better than crypto?Instead of just listing out all theorems, let’s say we’re just interested in one particular mathematical claim, and we want to know whether it’s true. Consider the following famous function:function collatz(n: number) {  while (n != 1) {    if (n % 2 == 0) n = n / 2;    else n = 3*n + 1;  }}Try it out! Does collatz(3) halt?YesNoOkay, now what about for any starting number? In 1937, Herr Collatz himself conjectured: “collatz(n) always halts, for every natural number n.” What do you think of this claim?True!False!Neither true nor false!I don’t know!There’s a $1M prize for proving the truth or non-truth of this famous conjecture. So let’s deploy our amazing function theorems() to earn some easy money! First, we write the conjecture in Lean:import Init.Data.Nat.Basicdef step (n: Nat): Nat :=  if n%2 == 0 then n/2 else 3*n + 1def coll_conj :=  ∀n, n>0 -> ∃s,    Nat.repeat step s n = 1Then we search through theorems() to see whether there’s a proof:const coll_conj = "...";function is_collatz_true() {  for (const t of theorems()) {    if (t === coll_conj) {      // Proof found! It must be true!      return true;    }  }  // No proof found! It must be false!  return false;}Here’s how it should work: if the conjecture is true, is_collatz_true should return true, and if the conjecture is false, is_collatz_true should return false.Now, imagine that the Collatz conjecture is false. Read the source: what does is_collatz_true do in this case?Return trueReturn falseLoop foreverThe problem is that we never actually search for a proof that the conjecture is false; we only search for a proof that it’s true!In Lean, the word ‘not’ is written as ¬. So the inverse of the conjecture is ¬coll_conj. So let’s just add that to our search!function is_stmt_true(s: string) {  for (const t of theorems()) {    if (t == s) return true;    if (t == "¬"+s) return false;  }}function is_collatz_true() {  return is_stmt_true(coll_conj);}This is looking better! We have an amazing function, is_stmt_true, that can tell us whether anything is true or false, given enough time!Read it through, and try to prove to yourself that is_collatz_true really does eventually return the truth of the Collatz conjecture.Okay, I tried to prove it ...Eventually, I think you’ll realize the algorithm relies on this assumption:  “theorems() contains either coll_conj or ¬coll_conj. It does not contain both, or neither.”This assumption is quite natural. We’ve already accepted that the Collatz conjecture is either true or false. So, similarly, theorems() should contain either coll_conj or ¬coll_conj. This gets to the heart of what Godel wanted to prove.Consistency 👎👍But what if theorems() contains both coll_conj and ¬coll_conj? Is that possible?YesNoI don’t knowThis property is known as consistency. Lean is ‘consistent’ if there are no statements S where both S and ¬S are theorems.Recall the ‘proof by contradiction’ method that we used in Chapter 1 to prove Turing’s theorem. The idea is that, if an assumption leads to a contradiction, the assumption must be false. The Lean system lets you use this proof method to generate theorems.Now, imagine that both coll_conj and ¬coll_conj are both theorems. Could we prove that 1+1=3 in Lean?YesNoI don’t knowWorse, we could use this method to prove anything in Lean! So, inconsistency would be disastrous. Mathematicians generally assume that their systems are consistent. (But it turns out to be rather hard to show it! We’ll see why in a future chapter!)ContinueCompletenessThis leaves one final possibility. What if theorems() contains neither coll_conj nor ¬coll_conj? How disastrous would that be? Could you use that to prove that 1+1=3 in Lean?YesNoI don’t knowIn general, the absence of a proof doesn’t lead to a complete collapse. It would just mean that Lean is not powerful enough to comment on the truth of the statement.However, it would still be extremely nice if Lean were able to say, one way or another, whether the Collatz conjecture is true. And it would be even nicer if Lean were able to say, one way or the other, whether any statement is true.If this were the case, we would say that Lean is complete. Precisely: if Lean is complete, then we can make any statement S, and either S or ¬S is in theorems().So, earlier when we tried to prove that is_stmt_true is a correct algorithm, we relied on the assumption that Lean is both consistent and complete.Okay, so, is that assumption true?A proof using Turing’s theoremSo, is Lean consistent and complete? Here’s Gödel’s famous answer: No, Lean is either inconsistent or incomplete!Our proof works by way of contradiction. The assumption: Lean is consistent and complete. We decided earlier that, if this is true, then our is_stmt_true function works perfectly.Now, recall the Halting Problem from the previous chapter. This problem asks for a function halts(tm) that returns true or false telling us whether the Turing Machine tm halts. With our is_stmt_true function, we can easily solve the Halting Problem!:function halts(tm: string) {  const lean_stmt = `halts ${tm}`;  return is_stmt_true(lean_stmt);}We saw earlier that Lean can talk about whether Turing Machines halt. So we can construct a Lean statement claiming that the Turing Machine tm halts. Then we just ... ask whether that statement is true!Easy! But hang on ...Yes! We also learned in Chapter 1 that the Halting Problem is impossible to solve! So we got a contradiction!The problem must be our initial assumption, that “Lean is consistent and complete.” We can therefore conclude that Lean is either inconsistent or incomplete!Okay, that’s Lean. What about other systems?What about other formal systems?In this chapter, we applied this reasoning to Lean, one specific formal system. But the same reasoning can be applied to any formal system F, with fairly minimal assumptions:1. F is enumerable. (This comes for free via the theorems trick.)2. We can reason about programs and halting in F.Gödel’s original proof was slightly stronger: it only required that F can reason about arithmetic, rather than programs and halting. But it turns out that pretty much any formal system can reason about programs — we’ll learn how easily in a future chapter!ConclusionYou might be wondering ... Okay, perhaps we can’t show that our systems of logic are complete, but perhaps we can at least show that they are consistent. But Gödel has some more bad news for you, coming up in the next chapter ...Finish chapter! 🥸If you want to know when the next chapter comes out, sign up for updates here! You might also enjoy our course Everyday Data Science, which teaches fundamental data science using the same interactive format.Next in Busy Beavers!:Coming soon6. Godel’s second incompleteness theoremNot satisfied with one bombshell, Kurt quickly arrived at a second. So what if there are things our systems can’t prove? Perhaps those things are unimportant anyway. Well, Kurt’s second theorem finds a very important thing that these systems can’t prove: their own consistency!In this chapter, we will learn why our systems, if they are consistent, cannot prove their own consistency. This builds neatly on top of the first theorem.<div class="Alert_root__xDLoq Alert_Warning__o75pu">JavaScript is disabled. Some features will not work.</div>Back in 1931, Kurt Gödel published his first mathematical mic-drop: “Our formal systems of logic can make statements that they can neither prove nor disprove.” In this chapter, you’ll learn what this famous theorem means, and you’ll learn a proof of it that builds upon Turing’s solution to the Halting Problem.Start chapterGödel’s theorem is about “formal systems”, but what are they? The standard examples on Wikipedia have weird names like “Zermelo–Fraenkel set theory with the axiom of choice”, and they use fancy math symbols like “∃x,y∈N”. You’d be forgiven for thinking ‘formality’ means black tie.∃x,y∈N∃x,y∈∃x,y∈NSo ... I can take off this tuxedo?Yes, because we’ll instead illustrate the theorem with a dirty, concrete formal system: the Lean proof assistant, a program made by Microsoft Research.the Lean proof assistantSuppose we wanted to say that “for all natural numbers n, 0+n=n”. In Lean, we could write this asn0+n=n0+0+n==(n : Nat) : 0 + n = nYou don’t need to understand the syntax precisely. Just scan over it and notice the 0 + n = n. Now, we could also use Lean to state that “there exists a natural number n, such that n=n+1”. What do you think of this?0 + n = nn=n+1n+1Such an n existsNo such n existsSuch an n existsNo such n existsMm ... I don’t think so. Take an example, say n=7. Here, n+1=8, and 7=8. This reasoning works for any n. If you can find an n where n=n+1, please email me!OkayMm ... I don’t think so. Take an example, say n=7. Here, n+1=8, and 7=8. This reasoning works for any n. If you can find an n where n=n+1, please email me!n=77n+1=81=87=87==OkayI don’t think so either.So, we need some way to distinguish true statements from false statements! Mathematicians do this using proofs. In Lean, we can prove our first statement with these magic words:proofs.theorem zero_add (n : Nat) : 0 + n = n:= by induction n with| zero => rfl| succ n ih => rw [Nat.add_succ, ih]theoremzero_addbywithLooks like some dark magic.Don’t sweat the details here! You just need to know that if we run the lean program on this file, it derives the statement that (n : Nat) : 0 + n = n. We can imagine lean as a function that takes a proof string, and either returns null (meaning the proof string is nonsense), or returns the statement string that it proves. Examples:leannull// An accepted proof yields a theoremlean("theorem zero_add ...")  === "(n : Nat) : 0 + n = n";// A nonsense proof proves nothinglean("nonsense") === null;// An accepted proof yields a theorem"theorem zero_add ...""==="(n : Nat) : 0 + n = n"// A nonsense proof proves nothing"nonsense"(Note that lean will always halt with either null or a theorem. It just runs the finite list of commands in the proof; it cannot loop forever.)Now let’s see what makes Lean a ‘formal system.’ A formal system has three things:A language to make statements. In Lean, those are things like (n : Nat) : 0 + n = n.statements. A language to make proofs. In Lean, those are things like theorem zero_add ..., which we saw earlier.theorem zero_add ...A way to interpret a proof string as a way to generate a proved statement, which we call a theorem. In the Lean formal system, that’s the program lean.theorem.Let’s find more theorems!So now the computer can help check our proofs. But finding theorems is still hard work! Can’t we get the computer to prove everything for us? How might we do that?findingHere’s an idea ... just list out all the possible strings! Every Lean theorem is just a string, so it must be somewhere in the list of all possible strings! Here’s how we can list all strings, in order of increasing length, using a JavaScript generator:generator// Long list of all Unicode chars!const alphabet = "abc...012...αβγ...";function* strings() {  yield "";  for (const s of strings())    for (const c of alphabet)      yield (s + c);}// Long list of all Unicode chars!constalphabet"abc...012...αβγ..."function*stringsyield""forsofcThis generates strings in length order, shortest first: all 0-char strings, then all 1-char strings, then all 2-char strings, and so on. The list looks like this:"", "a", "b", "c", ..., "aa", "ab", ..."a""b""c"..."aa""ab"Will the string "(n : Nat) : 0 + n = n" appear in this list?YesNoYesNoRight! This specific string will appear somewhere in the block of 21-char strings.Actually, it will appear, but it will take a while. Since the string "(n : Nat) : 0 + n = n" has 21 characters, it will turn up somewhere in the block of 21-char strings.OkayActually, it will appear, but it will take a while. Since the string "(n : Nat) : 0 + n = n" has 21 characters, it will turn up somewhere in the block of 21-char strings.But now we have a problem. For each string in the list, we want to ask whether it’s a theorem. Can we do that by passing it to the lean program?The lean program cannot tell us whether a statement is a theorem, because it does not accept statements as input. It accepts proofs as inputs! So instead, we will iterate through all strings, and try to interpret each string as a proof:statementsproofsprooffunction* theorems() {  for (const s of strings()) {    const t = lean(s);    if (t !== null) yield t;  }}theoremstif!==This procedure theorems() goes through every possible string, and for each, calls lean on it. If lean says the string is a valid proof, it outputs the theorem that it proves.So theorems() lists all the Lean theorems! Cool!Before we get too excited, let’s distinguish two things:The set of strings outputted by theorems()The set of strings that are Lean theoremsAre these the same sets? Let’s check. First, consider the earlier Lean statement, (n : Nat) : 0 + n = n. Will this statement eventually be found by theorems()?Yes, definitelyMaybe notYes, definitelyMaybe notRight: we saw earlier that this statement has a proof that is accepted by Lean. theorems() will eventually find that proof string, then output it.Actually, it will be found; it will just take a while. We know that this statement has a proof that Lean accepts: theorem zero_add .... That string is 115 characters long. That string will turn up in strings(), in the block of all 115-char strings.I seeActually, it will be found; it will just take a while. We know that this statement has a proof that Lean accepts: theorem zero_add .... That string is 115 characters long. That string will turn up in strings(), in the block of all 115-char strings.strings()I seeNext, consider some string x outputted by theorems(). Is it possible that x is not a Lean theorem? Read the source of theorems() to check.not Yes, theorems() could output a non-theorem!No, theorems() only outputs theorems.Yes, theorems() could output a non-theorem!No, theorems() only outputs theorems.Remember the definition of ‘theorem’: any string that’s returned by lean. Check the source: each value outputted by theorems() came from lean, so it must be a theorem.OkayRemember the definition of ‘theorem’: any string that’s returned by lean. Check the source: each value outputted by theorems() came from lean, so it must be a theorem.Right: theorems() only outputs a string if it has a proof that passes lean — that is to say, it’s a theorem.So, we’ve found that theorems() is indeed one and the same as the set of all theorems! Although, here’s one wrinkle ... let’s say we wait around until the theorem  (n : Nat) : 0 + n = n is outputted by theorems(). After that, is it possible that that same theorem could be outputted again?Yes, each theorem could appear many timesNo, each theorem appears onceYes, each theorem could appear many timesNo, each theorem appears onceRight.Actually, in general, it is possible!A theorem will be outputted once for every possible proof of that theorem. But this turns out to be unimportant; we can just de-duplicate these outputs.Right, so the computer can prove everything!Well ... the computer can generate all the Lean theorems. And that’s really cool! In fact, let’s take a moment to see just how cool it is ...This was a preview of chapter 5 of Busy Beavers!. To read all chapters, buy the course for $19. Yours forever.Busy Beavers!An interactive intro to Computability TheoryWhat can computers do? What are the limits of mathematics? And just how busy can a busy beaver be? In this course, you and I will take a practical and modern approach to answering these questions — or at least learning why some questions are unanswerable!The only prerequisite is that you’re comfortable coding. I prefer code like f(x) instead of math squiggles like Fx​. Less γs, more gs. I try to use modern concepts (strings) instead of the original hacks (Gödel numbering). I do examples first; abstraction later. I emphasize real-world languages (mainly JavaScript) rather than Turing Machines and pseudocode.This was a preview of chapter 5 of Busy Beavers!. To read all chapters, buy the course for $19. Yours forever.buy the course for $19Busy Beavers!An interactive intro to Computability TheoryWhat can computers do? What are the limits of mathematics? And just how busy can a busy beaver be? In this course, you and I will take a practical and modern approach to answering these questions — or at least learning why some questions are unanswerable!The only prerequisite is that you’re comfortable coding. I prefer code like f(x) instead of math squiggles like Fx​. Less γs, more gs. I try to use modern concepts (strings) instead of the original hacks (Gödel numbering). I do examples first; abstraction later. I emphasize real-world languages (mainly JavaScript) rather than Turing Machines and pseudocode.An interactive intro to Computability TheoryWhat can computers do? What are the limits of mathematics? And just how busy can a busy beaver be? In this course, you and I will take a practical and modern approach to answering these questions — or at least learning why some questions are unanswerable!The only prerequisite is that you’re comfortable coding. I prefer code like f(x) instead of math squiggles like Fx​. Less γs, more gs. I try to use modern concepts (strings) instead of the original hacks (Gödel numbering). I do examples first; abstraction later. I emphasize real-world languages (mainly JavaScript) rather than Turing Machines and pseudocode.f(x)Fx​Fx​​γgStatements like “x+0=x” seem a bit dull. Is Lean limited to arithmetic, or can it tackle more interesting math? In the previous chapter, we learned about the halting problem. That topic is surely mathematics! So can we ‘formalize’ it in Lean?x+0=xx+0=the previous chapterIt turns out, yes! We can teach Lean a simple language called the Turing Machine, and teach it how to run one. Then we can talk about whether a Turing Machine machine eventually halts. And here it is: a Lean (v3) proof of Turing’s theorem!:Turing Machinehow to run onehere it is: a Lean (v3) proof of Turing’s theorem!theorem halting_problem (n) :  ¬ computable_pred (λ c, (eval c n).dom)  | h :=  rice {f | (f n).dom} h nat.partrec.zero  nat.partrec.none trivialhalting_problemλSo Lean can prove that the halting problem is undecidable. But if you run theorems(), will it discover this theorem?Right: theorems() really does find every theorem!everyRemember: theorems() really does work! Since there is a Lean proof of Turing’s theorem, theorems() will eventually find it, then output the theorem.OkayRemember: theorems() really does work! Since there is a Lean proof of Turing’s theorem, theorems() will eventually find it, then output the theorem.And not only that: theorems() will find the shortest proof. Perhaps it’s much more elegant than the one we humans found. So, theorems() really is amazing! Let’s try it out, and see if we can win ourselves a mathematical prize!ContinueInstead of just listing out all theorems, let’s say we’re just interested in one particular mathematical claim, and we want to know whether it’s true. Consider the following famous function:allfunction collatz(n: number) {  while (n != 1) {    if (n % 2 == 0) n = n / 2;    else n = 3*n + 1;  }}functioncollatz:numberwhile!=%2==/else3*Try it out! Does collatz(3) halt?collatz(3)Actually, it halts after the following steps:n = 3. Odd, so triple it and add 1.n = 10. Even, so halve it.n = 5. Odd, so triple it and add 1.n = 16. Even, so halve it.n = 8. Even, so halve it.n = 4. Even, so halve it.n = 2. Even, so halve it.n = 1. Halt!OkayActually, it halts after the following steps:n = 3. Odd, so triple it and add 1.n = 10. Even, so halve it.n = 5. Odd, so triple it and add 1.n = 16. Even, so halve it.n = 8. Even, so halve it.n = 4. Even, so halve it.n = 2. Even, so halve it.n = 1. Halt!Okay, now what about for any starting number? In 1937, Herr Collatz himself conjectured: “collatz(n) always halts, for every natural number n.” What do you think of this claim?Herr Collatzcollatz(n)True!False!Neither true nor false!I don’t know!True!False!Neither true nor false!I don’t know!Well, Wikipedia says that nobody knows! If you genuinely have a proof, then glory and power awaits you! But my point is, the claim is either true or false.nobody knowsThat’s an interesting philosophical position! I disagree, though. Collatz’s claim seems well-defined, a bit like “all natural numbers n are either even or odd.” Imagine someone tomorrow revealed a genuine proof that the claim is true. Surely then it’s also true right now, even though we don’t know it yet?Okay, I accept that it’s either true or false.That’s an interesting philosophical position! I disagree, though. Collatz’s claim seems well-defined, a bit like “all natural numbers n are either even or odd.” Imagine someone tomorrow revealed a genuine proof that the claim is true. Surely then it’s also true right now, even though we don’t know it yet?Okay, I accept that it’s either true or false.Don’t worry, nobody else knows either! The point is, the claim is either true or false.nobody else knows eitherThere’s a $1M prize for proving the truth or non-truth of this famous conjecture. So let’s deploy our amazing function theorems() to earn some easy money! First, we write the conjecture in Lean:a $1M prizeimport Init.Data.Nat.Basicdef step (n: Nat): Nat :=  if n%2 == 0 then n/2 else 3*n + 1def coll_conj :=  ∀n, n>0 -> ∃s,    Nat.repeat step s n = 1importdefstepthencoll_conjThen we search through theorems() to see whether there’s a proof:const coll_conj = "...";function is_collatz_true() {  for (const t of theorems()) {    if (t === coll_conj) {      // Proof found! It must be true!      return true;    }  }  // No proof found! It must be false!  return false;}"..."is_collatz_true// Proof found! It must be true!returntrue// No proof found! It must be false!falseHere’s how it should work: if the conjecture is true, is_collatz_true should return true, and if the conjecture is false, is_collatz_true should return false.Now, imagine that the Collatz conjecture is false. Read the source: what does is_collatz_true do in this case?Return trueReturn falseLoop foreverReturn trueReturn falseLoop foreverInteresting. You seem to be saying that Lean has a proof that the conjecture is true, even though it’s false! And actually, that’s possible, and we’ll talk about that in a few minutes! But for now, let’s assume Lean is not that broken.Remember that theorems() searches the infinite list of all strings for proofs. Assuming the Collatz conjecture is false, and Lean is not broken, it should never find a valid proof of the conjecture. It will keep searching forever, so the loop will never finish, and is_collatz_true will never return.OkayInteresting. You seem to be saying that Lean has a proof that the conjecture is true, even though it’s false! And actually, that’s possible, and we’ll talk about that in a few minutes! But for now, let’s assume Lean is not that broken.thatRemember that theorems() searches the infinite list of all strings for proofs. Assuming the Collatz conjecture is false, and Lean is not broken, it should never find a valid proof of the conjecture. It will keep searching forever, so the loop will never finish, and is_collatz_true will never return.Remember that theorems() searches the infinite list of all strings. It will keep searching forever, so the loop will never finish, so is_collatz_true will never reach the return false line.OkayRemember that theorems() searches the infinite list of all strings. It will keep searching forever, so the loop will never finish, so is_collatz_true will never reach the return false line.return falseThe problem is that we never actually search for a proof that the conjecture is false; we only search for a proof that it’s true!In Lean, the word ‘not’ is written as ¬. So the inverse of the conjecture is ¬coll_conj. So let’s just add that to our search!¬¬coll_conjfunction is_stmt_true(s: string) {  for (const t of theorems()) {    if (t == s) return true;    if (t == "¬"+s) return false;  }}function is_collatz_true() {  return is_stmt_true(coll_conj);}is_stmt_truestring"¬"This is looking better! We have an amazing function, is_stmt_true, that can tell us whether anything is true or false, given enough time!Read it through, and try to prove to yourself that is_collatz_true really does eventually return the truth of the Collatz conjecture.Okay, I tried to prove it ...Eventually, I think you’ll realize the algorithm relies on this assumption:  “theorems() contains either coll_conj or ¬coll_conj. It does not contain both, or neither.”eitherorThis assumption is quite natural. We’ve already accepted that the Collatz conjecture is either true or false. So, similarly, theorems() should contain either coll_conj or ¬coll_conj. This gets to the heart of what Godel wanted to prove.But what if theorems() contains both coll_conj and ¬coll_conj? Is that possible?bothandYesNoI don’t knowI don’t knowThat’s a reasonable answer: maybe Lean’s rules allow for this! Although if you know of an example, you should file a bug report with the Lean developers. 😉You must really trust Lean! And you’re not alone: people working with formal systems generally assume that this can’t happen. But in general, a formal system can have both S and ¬S as theorems. It really just depends on the proof rules that they allow.S¬SMe neither! Really, it depends on the rules of Lean. If we trust Lean, it shouldn’t be possible. But in general, formal systems can have both S and ¬S as theorems. It really just depends on the proof rules that they allow.This property is known as consistency. Lean is ‘consistent’ if there are no statements S where both S and ¬S are theorems.consistency.Recall the ‘proof by contradiction’ method that we used in Chapter 1 to prove Turing’s theorem. The idea is that, if an assumption leads to a contradiction, the assumption must be false. The Lean system lets you use this proof method to generate theorems.Now, imagine that both coll_conj and ¬coll_conj are both theorems. Could we prove that 1+1=3 in Lean?1+1=3Right! Even though 1+1=3 is surely false, we could prove it in Lean using a proof by contradiction: “Let’s assume that ¬(1+1=3). But this leads to a contradiction: coll_conj and ¬coll_conj. We can therefore deduce that our assumption must be false, so 1+1=3.”1+¬(1+1=3)So, even though 1+1=3 is surely false, we could prove it in Lean like so: “Let’s assume that ¬(1+1=3). But this leads to a contradiction: coll_conj and ¬coll_conj. We can therefore deduce that our assumption must be false, so 1+1=3.”I see.So, even though 1+1=3 is surely false, we could prove it in Lean like so: “Let’s assume that ¬(1+1=3). But this leads to a contradiction: coll_conj and ¬coll_conj. We can therefore deduce that our assumption must be false, so 1+1=3.”I see.Worse, we could use this method to prove anything in Lean! So, inconsistency would be disastrous. Mathematicians generally assume that their systems are consistent. (But it turns out to be rather hard to show it! We’ll see why in a future chapter!)anythingdisastrous. This leaves one final possibility. What if theorems() contains neither coll_conj nor ¬coll_conj? How disastrous would that be? Could you use that to prove that 1+1=3 in Lean?neithernorIf you know how, let me know! I don’t think so either. At least, the proof by contradiction method can’t apply, since we don’t have a contradiction to work with.That’s fine. I don’t quite know either. the proof by contradiction method can’t apply, since we don’t have a contradiction to work with.In general, the absence of a proof doesn’t lead to a complete collapse. It would just mean that Lean is not powerful enough to comment on the truth of the statement.However, it would still be extremely nice if Lean were able to say, one way or another, whether the Collatz conjecture is true. And it would be even nicer if Lean were able to say, one way or the other, whether any statement is true.anyIf this were the case, we would say that Lean is complete. Precisely: if Lean is complete, then we can make any statement S, and either S or ¬S is in theorems().complete.So, earlier when we tried to prove that is_stmt_true is a correct algorithm, we relied on the assumption that Lean is both consistent and complete.Okay, so, is that assumption true?So, is Lean consistent and complete? Here’s Gödel’s famous answer: No, Lean is either inconsistent or incomplete!No, Lean is either inconsistent or incomplete!Our proof works by way of contradiction. The assumption: Lean is consistent and complete. We decided earlier that, if this is true, then our is_stmt_true function works perfectly.Lean is consistent and completeNow, recall the Halting Problem from the previous chapter. This problem asks for a function halts(tm) that returns true or false telling us whether the Turing Machine tm halts. With our is_stmt_true function, we can easily solve the Halting Problem!:the Halting Problem from the previous chapterhalts(tm)tmfunction halts(tm: string) {  const lean_stmt = `halts ${tm}`;  return is_stmt_true(lean_stmt);}haltslean_stmt`halts ${tm}``We saw earlier that Lean can talk about whether Turing Machines halt. So we can construct a Lean statement claiming that the Turing Machine tm halts. Then we just ... ask whether that statement is true!Easy! But hang on ...Yes! We also learned in Chapter 1 that the Halting Problem is impossible to solve! So we got a contradiction!The problem must be our initial assumption, that “Lean is consistent and complete.” We can therefore conclude that Lean is either inconsistent or incomplete!Lean is either inconsistent or incomplete!Okay, that’s Lean. What about other systems?In this chapter, we applied this reasoning to Lean, one specific formal system. But the same reasoning can be applied to any formal system F, with fairly minimal assumptions:1. F is enumerable. (This comes for free via the theorems trick.)2. We can reason about programs and halting in F.Gödel’s original proof was slightly stronger: it only required that F can reason about arithmetic, rather than programs and halting. But it turns out that pretty much any formal system can reason about programs — we’ll learn how easily in a future chapter!You might be wondering ... Okay, perhaps we can’t show that our systems of logic are complete, but perhaps we can at least show that they are consistent. But Gödel has some more bad news for you, coming up in the next chapter ...Finish chapter! 🥸If you want to know when the next chapter comes out, sign up for updates here! You might also enjoy our course Everyday Data Science, which teaches fundamental data science using the same interactive format.If you want to know when the next chapter comes out, sign up for updates here! You might also enjoy our course Everyday Data Science, which teaches fundamental data science using the same interactive format.Next in Busy Beavers!:Coming soon6. Godel’s second incompleteness theoremNot satisfied with one bombshell, Kurt quickly arrived at a second. So what if there are things our systems can’t prove? Perhaps those things are unimportant anyway. Well, Kurt’s second theorem finds a very important thing that these systems can’t prove: their own consistency!In this chapter, we will learn why our systems, if they are consistent, cannot prove their own consistency. This builds neatly on top of the first theorem.Next in Busy Beavers!:Coming soon6. Godel’s second incompleteness theoremNot satisfied with one bombshell, Kurt quickly arrived at a second. So what if there are things our systems can’t prove? Perhaps those things are unimportant anyway. Well, Kurt’s second theorem finds a very important thing that these systems can’t prove: their own consistency!In this chapter, we will learn why our systems, if they are consistent, cannot prove their own consistency. This builds neatly on top of the first theorem.6. Godel’s second incompleteness theoremNot satisfied with one bombshell, Kurt quickly arrived at a second. So what if there are things our systems can’t prove? Perhaps those things are unimportant anyway. Well, Kurt’s second theorem finds a very important thing that these systems can’t prove: their own consistency!In this chapter, we will learn why our systems, if they are consistent, cannot prove their own consistency. This builds neatly on top of the first theorem.Not satisfied with one bombshell, Kurt quickly arrived at a second. So what if there are things our systems can’t prove? Perhaps those things are unimportant anyway. Well, Kurt’s second theorem finds a very important thing that these systems can’t prove: their own consistency!In this chapter, we will learn why our systems, if they are consistent, cannot prove their own consistency. This builds neatly on top of the first theorem.You’re previewing chapter 5 of Busy Beavers!. Get all 9 chapters forever for $19.Quoted text: Send feedback 📩Your feedback will be sent privately to the author. They may reply to you by email. Thanks for helping make this course better!Quoted text: Send feedback 📩Your feedback will be sent privately to the author. They may reply to you by email. Thanks for helping make this course better!Send feedback 📩Your feedback will be sent privately to the author. They may reply to you by email. Thanks for helping make this course better!{"props":{"pageProps":{"lessonRoot":{"type":"root","docVersionType":"published","courseRoot":{"type":"course","docVersionType":"published","id":"C:tWWwvJDWlo","slug":"busy-beavers","author":{"id":"dummy","avatarKey":null,"name":null},"plaintextTitle":"Busy Beavers!","plaintextDescription":"What can computers do? What are the limits of mathematics? And just how busy can a busy beaver be? In this course, you and I will take a practical and modern approach to answering these questions — or at least learning why some questions are unanswerable!","approxLearnerCount":"37K","lessonIds":[null,null,"fr9uub3hqgab","L-il6foo6sa9","H7XOvXvC_x",null,"L-kx5ozDTpEU",null,null],"priceUsdDollars":19,"children":[{"type":"image","alt":"An illustration of a beaver writing numbers on a very long roll of tape","key":"c10dd89877cf93e87b31c342170ab2e604768c7d9e5172c3c740fa2a26035bca.png","darkMode":"invert","mimeType":"image/png","width":1600,"height":549},{"type":"h1","id":"busy-beavers","children":[{"text":"Busy Beavers!"}]},{"type":"h2","id":"an-interactive-intro-to-computability-theory","children":[{"text":"An interactive intro to Computability Theory"}]},{"type":"p","children":[{"text":"What can computers do? What are the limits of mathematics? And just how busy can a busy beaver be? In this course, you and I will take a practical and modern approach to answering these questions — or at least learning why some questions are unanswerable!"}]},{"type":"p","children":[{"text":"The only prerequisite is that you’re comfortable coding. I prefer code like "},{"type":"inlinecode","children":[{"text":"f(x)"}]},{"text":" instead of math squiggles like "},{"type":"inlinemath","htmlOrError":"\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.8414em;vertical-align:-0.15em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e\u003cspan class=\"mord mathfrak\"\u003eF\u003c/span\u003e\u003cspan class=\"msupsub\"\u003e\u003cspan class=\"vlist-t vlist-t2\"\u003e\u003cspan class=\"vlist-r\"\u003e\u003cspan class=\"vlist\" style=\"height:0.1514em;\"\u003e\u003cspan style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"\u003e\u003cspan class=\"pstrut\" style=\"height:2.7em;\"\u003e\u003c/span\u003e\u003cspan class=\"sizing reset-size6 size3 mtight\"\u003e\u003cspan class=\"mord mathnormal mtight\"\u003ex\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"vlist-s\"\u003e​\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"vlist-r\"\u003e\u003cspan class=\"vlist\" style=\"height:0.15em;\"\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e"},{"text":". Less "},{"type":"inlinemath","htmlOrError":"\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.05556em;\"\u003eγ\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e"},{"text":"s, more "},{"type":"inlinecode","children":[{"text":"g"}]},{"text":"s. I try to use modern concepts (strings) instead of the original hacks (Gödel numbering). I do examples first; abstraction later. I emphasize real-world languages (mainly JavaScript) rather than Turing Machines and pseudocode."}]},{"type":"buy","children":[{"text":"An easy computation: I want this course."}]},{"type":"p","children":[{"text":"(If you want to know when a new chapter comes out, ","italic":true},{"type":"link","children":[{"text":"sign up for updates here!","italic":true}],"href":"https://tigyog.app/d/C:tWWwvJDWlo/enrollment"},{"text":")","italic":true}]},{"type":"h2","id":"what-s-in-the-course","children":[{"text":"What’s in the course?"}]},{"type":"p","children":[{"text":"Ten chapters. Six are still in the oven, and they’ll arrive when they’re cooked. You’ll get your money’s worth (or your money back)."}]},{"type":"lessonlink","children":[{"type":"h1","id":"1-uncomputable-functions","children":[{"text":"1. Uncomputable functions"}]},{"type":"p","children":[{"text":"In this intro chapter, we’ll discover that there are functions that you can’t write in JavaScript (or any other programming language)."}]}],"lesson":null},{"type":"lessonlink","children":[{"type":"h1","id":"2-interpreters-and-universality","children":[{"text":"2. Interpreters and universality"}]},{"type":"p","children":[{"text":"A modern developer’s laptop is littered with VMs, containers, code sandboxes, et cetera. The concept of "},{"text":"simulation","italic":true},{"text":" might seem obvious — but it certainly wasn’t when Alan Turing discovered the concept. In this chapter, we’ll implement an "},{"text":"interpreter","italic":true},{"text":", which is the modern equivalent of Turing’s “Universal Computing Machine”, and which is key to understanding Turing’s solution to the halting problem."}]}],"lesson":null},{"type":"lessonlink","children":[{"type":"h1","id":"3-the-halting-problem","children":[{"text":"3. The halting problem"}]},{"type":"h2","id":"or-turing-s-trick-to-troll-any-termination-test","children":[{"text":"Or, Turing’s trick to troll any termination test"}]},{"type":"p","children":[{"text":"Perhaps your IDE has warned you before: “this code is unreachable”. How useful! Can we get your IDE to warn you about all lines that are unreachable. Back in 1936, before computers really existed, Alan Turing was already thinking about this problem, and he has bad news for you ..."}]},{"type":"p","children":[{"bold":true,"text":"(This chapter is free while stocks last!)"}]}],"lesson":{"id":"fr9uub3hqgab","slug":["busy-beavers","the-halting-problem"],"plaintextTitle":"The halting problem","docVersionType":"published","sections":[{"title":[{"text":"The halting problem"}],"id":"the-halting-problem","promptIds":[]},{"title":[{"text":"An interactive tutorial"}],"id":"an-interactive-tutorial","promptIds":["pr-sraw3zkm1qsk"]},{"title":[{"text":"What is ‘halting’?"}],"id":"what-is-halting","promptIds":["pr-r6djuvhoew07","pr-h7e4aqmip86h"]},{"title":[{"text":"The "},{"type":"inlinecode","children":[{"text":"halts"}]},{"text":" function"}],"id":"the-halts-function","promptIds":["pr-2HJaiGEdb0"]},{"title":[{"text":"Implementing "},{"type":"inlinecode","children":[{"text":"halts"}]},{"text":""}],"id":"implementing-halts","promptIds":["pr-PSbnVE54M7","pr-fqWd9IWCAP","pr-IP7eTLHhYF"]},{"title":[{"text":"Paradoxical self-reference"}],"id":"paradoxical-self-reference","promptIds":["pr-x9q26hISZD","pr-Ijzz6tHb9a"]},{"title":[{"text":"The "},{"type":"inlinecode","children":[{"text":"haltsOn"}]},{"text":" function"}],"id":"the-halts-on-function","promptIds":["pr-odeOO5NqZO","pr-b6htfzz0s19u"]},{"title":[{"text":"Self-reflecting functions 🪞"}],"id":"self-reflecting-functions","promptIds":["pr-umygYmgYCh","pr-MGt81gc7Id","pr-92SJz8SSu7"]},{"title":[{"text":"Turing’s "},{"type":"inlinecode","children":[{"text":"troll"}]},{"text":" function 👺"}],"id":"turing-s-troll-function","promptIds":["pr-o9tq8m2jezp3","pr-k8k2xk1m15mj"]},{"title":[{"text":"Trolling the "},{"type":"inlinecode","children":[{"text":"troll"}]},{"text":" 👺🪞"}],"id":"trolling-the-troll","promptIds":[]},{"title":[{"text":"If the "},{"type":"inlinecode","children":[{"text":"troll"}]},{"text":" halts on its own code ..."}],"id":"if-the-troll-halts-on-its-own-code","promptIds":["pr-02tuo110jfi8","pr-5aygghu1zao9"]},{"title":[{"text":"If the "},{"type":"inlinecode","children":[{"text":"troll"}]},{"text":" does not halt on its own code ..."}],"id":"if-the-troll-does-not-halt-on-its-own-code","promptIds":["pr-zkax6xivmadi","pr-nCMxrUNepY"]},{"title":[{"text":"Equivalence of "},{"type":"inlinecode","children":[{"text":"halts"}]},{"text":" and "},{"type":"inlinecode","children":[{"text":"haltsOn"}]},{"text":""}],"id":"equivalence-of-halts-and-halts-on","promptIds":["pr-pbelcdi0c3sm","pr-rp9PwWaWsO"]},{"title":[{"text":"Can we patch the bug? 🐛"}],"id":"can-we-patch-the-bug","promptIds":["pr-90LNbAKSz0"]},{"title":[{"text":"Conclusion"}],"id":"conclusion","promptIds":["pr-si562wjwp7tq"]}]}},{"type":"lessonlink","children":[{"type":"h1","id":"4-proofs-about-programs","children":[{"text":"4. Proofs about programs"}]},{"type":"p","children":[{"text":"Hang on, didn’t we just prove computers can’t decide whether programs halt? Not so fast! In this chapter, we’ll use "},{"bold":true,"text":"Lean"},{"text":", a programming language and proof assistant, to prove whether some specific programs halt. Suck it, Turing!"}]}],"lesson":{"id":"L-il6foo6sa9","slug":["busy-beavers","proofs-about-programs"],"plaintextTitle":"Proofs about programs","docVersionType":"published","sections":[{"title":[{"text":"Proofs about programs"}],"id":"proofs-about-programs","promptIds":[]},{"title":[{"text":"An interactive tutorial"}],"id":"an-interactive-tutorial","promptIds":["pr-jsosdr2uoo","pr-6lw5vwg-n6","pr-h-8343x66o","pr-cakl46el-8"]},{"title":[{"text":"Mathematical induction 🍳"}],"id":"mathematical-induction","promptIds":["pr-pzid60adiv","pr-kxow-3z6hb","pr-x2x-4ch4tj"]},{"title":[{"text":"Once more, in Lean"}],"id":"once-more-in-lean","promptIds":["pr-7d4wqcq9d0"]},{"title":[{"text":"The Ackermann function ♾️"}],"id":"the-ackermann-function","promptIds":["pr-jft0t4nygr","pr-51gt0kg5n7","pr-u1-7i6266-","pr-oqcjekm-lb","pr-98ju6uv7mr","pr-tdgx2x1wzm"]},{"title":[{"text":"Noetherian induction"}],"id":"noetherian-induction","promptIds":["pr-zdgatixhq0","pr-yoz4tvmv-u"]},{"title":[{"text":"Well-ordering"}],"id":"well-ordering","promptIds":["pr-z3p28k0by6","pr-mlkfykjxs8","pr-hu70w2yy2-"]},{"title":[{"text":"Proving machines halt 🤚"}],"id":"proving-machines-halt","promptIds":["pr-btchz-vtf9","pr-k339d9whp0","pr-aud7tl8-pm","pr-llh2bxwcp9","pr-yxo59mqxt8","pr-gg3k1569cx"]},{"title":[{"text":"Proving programs "},{"text":"don’t","italic":true},{"text":" halt ➿"}],"id":"proving-programs-don-t-halt","promptIds":["pr-ex6fs6zhqi","pr-5yxce08ept","pr-de7x7wtey4","pr-p5lutj6thk","pr-zja2bxgjix","pr-qkrvgen0-m","pr-vv1kkz6st9"]},{"title":[{"text":"Conclusion"}],"id":"conclusion","promptIds":["pr-l8gmes-csa"]},{"title":[{"text":"Endnotes"}],"id":"endnotes","promptIds":[]}]}},{"type":"lessonlink","children":[{"type":"h1","id":"5-goedel-s-first-incompleteness-theorem","children":[{"text":"5. Gödel’s first incompleteness theorem"}]},{"type":"p","children":[{"text":"Back in 1931, Kurt Gödel published his first mathematical mic-drop: “Our formal systems of logic can make statements that they can neither prove nor disprove.” In this chapter, you’ll learn what this famous theorem means, and you’ll learn a proof of it that builds upon Turing’s solution to the Halting Problem."}]}],"lesson":{"id":"H7XOvXvC_x","slug":["busy-beavers","incompleteness"],"plaintextTitle":"Gödel’s first incompleteness theorem","docVersionType":"published","sections":[{"title":[{"text":"Gödel’s first incompleteness theorem"}],"id":"goedel-s-first-incompleteness-theorem","promptIds":[]},{"title":[{"text":"An interactive tutorial"}],"id":"an-interactive-tutorial","promptIds":["pr-lo2wB07yq3"]},{"title":[{"text":"What is a formal system? 🤵"}],"id":"what-is-a-formal-system","promptIds":["pr-PXcWIg-yWb","pr-wG0HafYvWn","pr-YwO9MLGwG8","pr-O0eXG3iLZb"]},{"title":[{"text":"Enumerating theorems ... 🔢"}],"id":"enumerating-theorems-1234","promptIds":["pr-r6FsNuKrqA","pr-btUSPwY_eN","pr-UbeXwRTmto"]},{"title":[{"text":"Does "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":" do what it says on the tin? 🥫"}],"id":"does-theorems-do-what-it-says-on-the-tin","promptIds":["pr-TZaZCzSakq","pr-C4HniZw82O","pr-ZBBORLTx-s","pr--BLQSz0jrg"]},{"title":[{"text":"Statements about programs! 👩‍💻"}],"id":"statements-about-programs","promptIds":["pr-UxPQRS-0nJ","pr-1yLX9JWXp1"]},{"title":[{"text":"Theorem mining — better than crypto?"}],"id":"theorem-mining-better-than-crypto","promptIds":["pr-s09KgNpUw2","pr-k9xoym0KXX","pr-bOwqC8tvmD","pr-bi0Erwim75"]},{"title":[{"text":"Consistency 👎👍"}],"id":"consistency","promptIds":["pr-oFxPwW-3NU","pr-Anm-v3p-E_","pr-7UgUKxVWjv"]},{"title":[{"text":"Completeness"}],"id":"completeness","promptIds":["pr-rg_gR36DIZ","pr-9Qnbi1bWV8"]},{"title":[{"text":"A proof using Turing’s theorem"}],"id":"a-proof-using-turing-s-theorem","promptIds":["pr-0SYVvh63uT","pr-puBPdsiIyA"]},{"title":[{"text":"What about other formal systems?"}],"id":"what-about-other-formal-systems","promptIds":[]},{"title":[{"text":"Conclusion"}],"id":"conclusion","promptIds":["pr-gO9xwgsQNU"]}]}},{"type":"lessonlink","children":[{"type":"h1","id":"6-godel-s-second-incompleteness-theorem","children":[{"text":"6. Godel’s second incompleteness theorem"}]},{"type":"p","children":[{"text":"Not satisfied with one bombshell, Kurt quickly arrived at a second. So what if there are things our systems can’t prove? Perhaps those things are unimportant anyway. Well, Kurt’s second theorem finds a very important thing that these systems can’t prove: their own consistency!"}]},{"type":"p","children":[{"text":"In this chapter, we will learn why our systems, if they are consistent, cannot prove their own consistency. This builds neatly on top of the first theorem."}]}],"lesson":null},{"type":"lessonlink","children":[{"type":"h1","id":"7-rice-s-theorem","children":[{"text":"7. Rice’s theorem"}]},{"type":"p","children":[{"text":"Your coworker’s function "},{"type":"inlinecode","children":[{"text":"is_ip_address"}]},{"text":" could be replaced by a regular expression. Perhaps your IDE could recommend when a function can be replaced by a regex? Unfortunately, Henry Rice showed in 1951 that this check, along with many others like it, is impossible. Let’s follow the proof."}]}],"lesson":{"id":"L-kx5ozDTpEU","slug":["busy-beavers","rice"],"plaintextTitle":"Rice’s theorem","docVersionType":"published","sections":[{"title":[{"text":"Rice’s theorem"}],"id":"rice-s-theorem","promptIds":[]},{"title":[{"text":"An interactive tutorial"}],"id":"an-interactive-tutorial","promptIds":["pr-FR3Y7GBXaM","pr-P5_j0yoGp4","pr-LqkhhdqBjK"]},{"title":[{"text":"Warm-up: "},{"type":"inlinecode","children":[{"text":"canBeRegex"}]},{"text":""}],"id":"warm-up-can-be-regex","promptIds":["pr-_R1hkhQJsw","pr-JHEjDLW0Rt","pr-vrtG_yr4bH","pr-jQt8j9UoBr"]},{"title":[{"text":"That old halting problem again"}],"id":"that-old-halting-problem-again","promptIds":["pr-taL-T4xB7r","pr-es1QpxjfLK","pr-dTIcnerANM","pr-0EUVIqtP27"]},{"title":[{"text":"Code isolation"}],"id":"code-isolation","promptIds":["pr-7bjr0rlt--","pr-RqyZhQR3_N"]},{"title":[{"text":""},{"type":"inlinecode","children":[{"text":"canHalt"}]},{"text":": maybe an easier question?"}],"id":"can-halt-maybe-an-easier-question","promptIds":["pr-rAFRxXjypg","pr-qHJlUGF364","pr-051OGpHsLi"]},{"title":[{"text":"Final boss: "},{"type":"inlinecode","children":[{"text":"numHaltsIsEven"}]},{"text":""}],"id":"final-boss-num-halts-is-even","promptIds":["pr-tV1xURTrdc","pr-3p4h25JzLu","pr-RkY873FFkR","pr-BrzsBw2SuS","pr-PYGx3xXqXo"]},{"title":[{"text":"Now for an any property "},{"type":"inlinemath","htmlOrError":"\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.6833em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.13889em;\"\u003eP\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e"},{"text":""}],"id":"now-for-an-any-property-p","promptIds":["pr-rrzXa-FbDM","pr-AzcWH_3W8P"]},{"title":[{"text":"Too many variables"}],"id":"too-many-variables","promptIds":["pr-4YEusa7i_h","pr-pWKKnvn8nZ","pr-01k_721zz5","pr-gYUxzze-44"]},{"title":[{"text":"Solving the halting problem is trivial?!"}],"id":"solving-the-halting-problem-is-trivial","promptIds":["pr-KYQ8VpKmTe","pr-rZriuogKRw","pr-l1zJOH9qLc"]},{"title":[{"text":"Conclusion"}],"id":"conclusion","promptIds":["pr-gO9xwgsQNU"]}]}},{"type":"lessonlink","children":[{"type":"h1","id":"8-just-how-busy-can-a-busy-beaver-be","children":[{"text":"8. Just how busy can a busy beaver be?"}]},{"type":"p","children":[{"text":"Let’s play a game! We’ll write a JavaScript program of less than 10 characters that prints as much as possible before halting. Whoever’s program prints more is the busiest beaver, and they win the game."}]},{"type":"p","children":[{"text":"What’s the busiest program? Just how busy is it? How can we find it? In this chapter, we’ll have a crack at these questions, but fair warning: we might not get many answers."}]}],"lesson":null},{"type":"lessonlink","children":[{"type":"h1","id":"9-quines-and-fixed-points","children":[{"text":"9. Quines and fixed points"}]},{"type":"p","children":[{"text":"Your DNA is a program that, when executed by a messy chemical computer (you!), spits out copies of itself. Are there JavaScript programs that perform the same trick when executed by "},{"type":"inlinecode","children":[{"text":"node"}]},{"text":"? What about Python? In this chapter, we’ll discover what a language needs in order to allow for self-replication."}]}],"lesson":null},{"type":"p","children":[{"text":"One more chapter to be announced. Watch this space.","italic":true}]},{"type":"buy","children":[{"text":"$19 is less than a Norwegian beaver pays for two pints!"}]},{"type":"h2","id":"who-am-i","children":[{"text":"Who am I?"}]},{"type":"p","children":[{"text":"I’m Jim. I studied computer science at Imperial College. I also have ten years of experience in the software industry — enough to know that you’ll probably never need any of this computability theory to make cool stuff, but you "},{"text":"might","italic":true},{"text":" need it to impress your friends."}]},{"type":"p","children":[{"text":""},{"type":"link","children":[{"text":"I also write at jameshfisher.com."}],"href":"https://jameshfisher.com/"},{"text":" You might know me from some "},{"type":"link","children":[{"text":"phishing"}],"href":"https://news.ycombinator.com/item?id=16781959"},{"text":" "},{"type":"link","children":[{"text":"techniques"}],"href":"https://news.ycombinator.com/item?id=19768072"},{"text":" I "},{"type":"link","children":[{"text":"discovered"}],"href":"https://jameshfisher.com/2020/08/06/smear-phishing-how-to-scam-an-android-user/"},{"text":". I also happen to be the creator of "},{"type":"link","children":[{"text":"TigYog"}],"href":"https://tigyog.app"},{"text":", the app that this course is built with."}]},{"type":"h2","id":"what-people-are-saying","children":[{"text":"What people are saying ..."}]},{"type":"p","children":[{"text":"Over 30K learners have completed chapters in "},{"text":"Busy Beavers","italic":true},{"text":". Here are some things that they’ve said about it."}]},{"type":"callout","children":[{"type":"p","children":[{"text":"⭐⭐⭐⭐⭐ “Probably the best intro to computability theory I’ve ever seen.” "},{"text":"— David Brumley, ","italic":true},{"type":"link","children":[{"text":"professor at Carnegie Mellon","italic":true}],"href":"https://users.ece.cmu.edu/~dbrumley/"},{"text":" and ","italic":true},{"type":"link","children":[{"text":"ForAllSecure CEO","italic":true}],"href":"https://forallsecure.com/"},{"text":".","italic":true}]}]},{"type":"callout","children":[{"type":"p","children":[{"text":"⭐⭐⭐⭐⭐ “A great, accessible way to introduce Lean to my students!” — "},{"type":"link","children":[{"text":"Tyler Josephson","italic":true}],"href":"https://twitter.com/trjosephson"},{"text":", chemical engineering professor at ","italic":true},{"type":"link","children":[{"text":"UMBC","italic":true}],"href":"https://cbee.umbc.edu/"},{"text":".","italic":true}]}]},{"type":"callout","children":[{"type":"p","children":[{"text":"⭐⭐⭐⭐⭐ “Your "},{"text":"Busy Beavers","italic":true},{"text":" course reminds me of how it felt to read a book when I was a kid. You’ve taken theory that’s usually packed in a scary thick textbook, and turned it into a book that children could read. Awesome work!” — "},{"text":"Reviewer by email.","italic":true}]}]},{"type":"callout","children":[{"type":"p","children":[{"text":"⭐⭐⭐⭐⭐ “This was very satisfying. The format works well, and makes sure you as reader are doing at least a minimum amount of thinking about the topics being presented. Even the pops and dings (if you have sound on) are fun 🙂” — "},{"type":"link","children":[{"text":"Reviewer on HN","italic":true}],"href":"https://news.ycombinator.com/item?id=33743418"},{"text":".","italic":true}]}]},{"type":"callout","children":[{"type":"p","children":[{"text":"⭐⭐⭐⭐⭐ “Absolutely fascinating and a lot of fun!”"},{"text":" — John George, Senior DevOps engineer, by email.","italic":true}]}]},{"type":"callout","children":[{"type":"p","children":[{"text":"⭐⭐⭐⭐⭐ “Thanks for your hard work and attention to detail; this entire series has been delightful.”"},{"text":" — ","italic":true},{"type":"link","children":[{"text":"Reviewer on Lobste.rs","italic":true}],"href":"https://lobste.rs/s/yequwk/proofs_about_programs_interactive"},{"text":".","italic":true}]}]},{"type":"h2","id":"glossary-of-unused-words","children":[{"text":"Glossary of unused words 📖"}]},{"type":"p","children":[{"text":"Standard writing on computability theory has its own weird vocabulary. I try to avoid using it, and instead use modern developer vocabulary. Here are some examples of weird words you won’t see much of in this course.","italic":true}]},{"type":"p","children":[{"bold":true,"text":"Decidable"},{"text":", "},{"text":"adj","italic":true},{"text":". If you can write "},{"type":"inlinecode","children":[{"text":"isMember"}]},{"text":" that returns whether a value is a member of a set, then the set is "},{"bold":true,"text":"decidable,"},{"text":" or "},{"bold":true,"text":"recursive,"},{"text":" or "},{"bold":true,"text":"computable."}]},{"type":"p","children":[{"bold":true,"text":"Diverge"},{"text":", "},{"text":"v","italic":true},{"text":". To run forever; to never return or exit. (Can also include throwing an exception.)"}]},{"type":"p","children":[{"bold":true,"text":"Function"},{"text":", "},{"text":"n","italic":true},{"text":". An abstract mapping from one set to another, e.g. “the function that maps programs to whether they halt or not”. "},{"text":"Not","italic":true},{"text":" the same as what developers call a "},{"type":"inlinecode","children":[{"text":"function"}]},{"text":", which mathematicatians would call an “algorithm” or “procedure.”"}]},{"type":"buy","children":[{"text":"Giveaway, "},{"text":"n","italic":true},{"text":". A surprisingly cheap item; excellent value for money."}]},{"type":"p","children":[{"bold":true,"text":"Gödel number"},{"text":", "},{"text":"n","italic":true},{"text":". A number that uniquely identifies a program. Nowadays we identify programs by their "},{"text":"source code","italic":true},{"text":" instead, and we have no need to assign numbers to programs."}]},{"type":"p","children":[{"bold":true,"text":"Language"},{"text":", "},{"text":"n","italic":true},{"text":". A set of strings, e.g. "},{"type":"inlinecode","children":[{"text":"[\"foo\", \"bar\"]"}]},{"text":", or all strings that only use the character "},{"type":"inlinecode","children":[{"text":"\"a\""}]},{"text":"."}]},{"type":"p","children":[{"bold":true,"text":"Partial"},{"text":", "},{"text":"adj","italic":true},{"text":". Undefined on some inputs."}]},{"type":"p","children":[{"bold":true,"text":"Recursive"},{"text":", "},{"text":"adj","italic":true},{"text":". See "},{"bold":true,"text":"decidable."},{"text":" "},{"text":"Not","italic":true},{"text":" the same as what developers call “recursive”, which is a function that calls itself."}]},{"type":"p","children":[{"bold":true,"text":"Recursively enumerable"},{"text":", "},{"text":"adj","italic":true},{"text":". If you can write "},{"type":"inlinecode","children":[{"text":"listMembers"}]},{"text":" that prints out all members of a set, then the set is recursively enumerable."}]},{"type":"p","children":[{"bold":true,"text":"Semantics"},{"text":", "},{"text":"n","italic":true},{"text":". Generally means “the input-output behavior of the code.”"}]}]},"id":"H7XOvXvC_x","slug":["busy-beavers","incompleteness"],"author":{"id":"ac-jw38s7hchupg","avatarKey":"bf90c3a21a9498fd7071f4b1f3b667c6618fa2861ad49ebf2d15bda533f72023.jpeg","name":"Jim Fisher"},"plaintextTitle":"Gödel’s first incompleteness theorem","plaintextDescription":"Back in 1931, Kurt Gödel published his first mathematical mic-drop: “Our formal systems of logic can make statements that they can neither prove nor disprove.” In this chapter, you’ll learn what this famous theorem means, and you’ll learn a proof of it that builds upon Turing’s solution to the Halting Problem.","sections":[{"title":[{"text":"Gödel’s first incompleteness theorem"}],"id":"goedel-s-first-incompleteness-theorem","promptIds":[]},{"title":[{"text":"An interactive tutorial"}],"id":"an-interactive-tutorial","promptIds":["pr-lo2wB07yq3"]},{"title":[{"text":"What is a formal system? 🤵"}],"id":"what-is-a-formal-system","promptIds":["pr-PXcWIg-yWb","pr-wG0HafYvWn","pr-YwO9MLGwG8","pr-O0eXG3iLZb"]},{"title":[{"text":"Enumerating theorems ... 🔢"}],"id":"enumerating-theorems-1234","promptIds":["pr-r6FsNuKrqA","pr-btUSPwY_eN","pr-UbeXwRTmto"]},{"title":[{"text":"Does "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":" do what it says on the tin? 🥫"}],"id":"does-theorems-do-what-it-says-on-the-tin","promptIds":["pr-TZaZCzSakq","pr-C4HniZw82O","pr-ZBBORLTx-s","pr--BLQSz0jrg"]},{"title":[{"text":"Statements about programs! 👩‍💻"}],"id":"statements-about-programs","promptIds":["pr-UxPQRS-0nJ","pr-1yLX9JWXp1"]},{"title":[{"text":"Theorem mining — better than crypto?"}],"id":"theorem-mining-better-than-crypto","promptIds":["pr-s09KgNpUw2","pr-k9xoym0KXX","pr-bOwqC8tvmD","pr-bi0Erwim75"]},{"title":[{"text":"Consistency 👎👍"}],"id":"consistency","promptIds":["pr-oFxPwW-3NU","pr-Anm-v3p-E_","pr-7UgUKxVWjv"]},{"title":[{"text":"Completeness"}],"id":"completeness","promptIds":["pr-rg_gR36DIZ","pr-9Qnbi1bWV8"]},{"title":[{"text":"A proof using Turing’s theorem"}],"id":"a-proof-using-turing-s-theorem","promptIds":["pr-0SYVvh63uT","pr-puBPdsiIyA"]},{"title":[{"text":"What about other formal systems?"}],"id":"what-about-other-formal-systems","promptIds":[]},{"title":[{"text":"Conclusion"}],"id":"conclusion","promptIds":["pr-gO9xwgsQNU"]}],"children":[{"type":"h1","id":"goedel-s-first-incompleteness-theorem","children":[{"text":"Gödel’s first incompleteness theorem"}]},{"type":"h2","id":"an-interactive-tutorial","children":[{"text":"An interactive tutorial"}]},{"type":"p","children":[{"text":"Back in 1931, Kurt Gödel published his first mathematical mic-drop: “Our formal systems of logic can make statements that they can neither prove nor disprove.” In this chapter, you’ll learn what this famous theorem means, and you’ll learn a proof of it that builds upon Turing’s solution to the Halting Problem."}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Start chapter"}],"id":"op-_App1U5dZo"},{"text":""}],"id":"pr-lo2wB07yq3"},{"type":"h2","id":"what-is-a-formal-system","children":[{"text":"What is a formal system? 🤵"}]},{"type":"p","children":[{"text":"Gödel’s theorem is about “formal systems”, but what are they? The standard examples on Wikipedia have weird names like “Zermelo–Fraenkel set theory with the axiom of choice”, and they use fancy math symbols like “"},{"type":"inlinemath","htmlOrError":"\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e∃\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003ex\u003c/span\u003e\u003cspan class=\"mpunct\"\u003e,\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.1667em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\" style=\"margin-right:0.03588em;\"\u003ey\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2778em;\"\u003e\u003c/span\u003e\u003cspan class=\"mrel\"\u003e∈\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2778em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.6889em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathbb\"\u003eN\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e"},{"text":"”. You’d be forgiven for thinking ‘formality’ means black tie."}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"So ... I can take off this tuxedo?"}],"id":"op-SgdkweHYmb"},{"text":""}],"id":"pr-PXcWIg-yWb"},{"type":"p","children":[{"text":"Yes, because we’ll instead illustrate the theorem with a dirty, concrete formal system: "},{"type":"link","children":[{"bold":true,"text":"the Lean proof assistant"}],"href":"https://leanprover.github.io/"},{"text":", a program made by Microsoft Research."}]},{"type":"p","children":[{"text":"Suppose we wanted to say that “for all natural numbers "},{"type":"inlinemath","htmlOrError":"\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.4306em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003en\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e"},{"text":", "},{"type":"inlinemath","htmlOrError":"\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e0\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222em;\"\u003e\u003c/span\u003e\u003cspan class=\"mbin\"\u003e+\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.4306em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003en\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2778em;\"\u003e\u003c/span\u003e\u003cspan class=\"mrel\"\u003e=\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2778em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.4306em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003en\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e"},{"text":"”. In Lean, we could write this as"}]},{"type":"blockcode","html":"(n : Nat) : \u003cspan class=\"pl-c1\"\u003e0\u003c/span\u003e + n = n"},{"type":"p","children":[{"text":"You don’t need to understand the syntax precisely. Just scan over it and notice the "},{"type":"inlinecode","children":[{"text":"0 + n = n"}]},{"text":". Now, we could also use Lean to state that “there exists a natural number "},{"type":"inlinemath","htmlOrError":"\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.4306em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003en\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e"},{"text":", such that "},{"type":"inlinemath","htmlOrError":"\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.4306em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003en\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2778em;\"\u003e\u003c/span\u003e\u003cspan class=\"mrel\"\u003e=\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2778em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003en\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222em;\"\u003e\u003c/span\u003e\u003cspan class=\"mbin\"\u003e+\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.6444em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e1\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e"},{"text":"”. What do you think of this?"}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Such an "},{"type":"inlinemath","htmlOrError":"\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.4306em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003en\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e"},{"text":" exists"}],"id":"op-sk2DdRT_4E","correct":false},{"text":""},{"type":"option","children":[{"text":"No such "},{"type":"inlinemath","htmlOrError":"\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.4306em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003en\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e"},{"text":" exists"}],"id":"op-evDapYDOnG","correct":true},{"text":""}],"id":"pr-wG0HafYvWn"},{"type":"response","children":[{"type":"p","children":[{"text":"Mm ... I don’t think so. Take an example, say "},{"type":"inlinemath","htmlOrError":"\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.4306em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003en\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2778em;\"\u003e\u003c/span\u003e\u003cspan class=\"mrel\"\u003e=\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2778em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.6444em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e7\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e"},{"text":". Here, "},{"type":"inlinemath","htmlOrError":"\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003en\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222em;\"\u003e\u003c/span\u003e\u003cspan class=\"mbin\"\u003e+\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.6444em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e1\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2778em;\"\u003e\u003c/span\u003e\u003cspan class=\"mrel\"\u003e=\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2778em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.6444em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e8\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e"},{"text":", and "},{"type":"inlinemath","htmlOrError":"\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e7\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2778em;\"\u003e\u003c/span\u003e\u003cspan class=\"mrel\"\u003e\u003cspan class=\"mrel\"\u003e\u003cspan class=\"mord vbox\"\u003e\u003cspan class=\"thinbox\"\u003e\u003cspan class=\"rlap\"\u003e\u003cspan class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"\u003e\u003c/span\u003e\u003cspan class=\"inner\"\u003e\u003cspan class=\"mord\"\u003e\u003cspan class=\"mrel\"\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"fix\"\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"mrel\"\u003e=\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2778em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.6444em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e8\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e"},{"text":". This reasoning works for any "},{"type":"inlinemath","htmlOrError":"\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.4306em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003en\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e"},{"text":". If you can find an "},{"type":"inlinemath","htmlOrError":"\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.4306em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003en\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e"},{"text":" where "},{"type":"inlinemath","htmlOrError":"\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.4306em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003en\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2778em;\"\u003e\u003c/span\u003e\u003cspan class=\"mrel\"\u003e=\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2778em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003en\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222em;\"\u003e\u003c/span\u003e\u003cspan class=\"mbin\"\u003e+\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.6444em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e1\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e"},{"text":", please email me!"}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Okay"}],"id":"op-sb6NXFz2X5"},{"text":""}],"id":"pr-JeLOZZdSKU"}],"toPromptId":"pr-wG0HafYvWn","optionIds":["op-sk2DdRT_4E"]},{"type":"response","children":[{"type":"p","children":[{"text":"I don’t think so either."}]}],"toPromptId":"pr-wG0HafYvWn","optionIds":["op-evDapYDOnG"]},{"type":"p","children":[{"text":"So, we need some way to distinguish true statements from false statements! Mathematicians do this using "},{"bold":true,"text":"proofs."},{"text":" In Lean, we can prove our first statement with these magic words:"}]},{"type":"blockcode","html":"\u003cspan class=\"pl-k\"\u003etheorem\u003c/span\u003e \u003cspan class=\"pl-en\"\u003ezero_add\u003c/span\u003e (n : Nat) : \u003cspan class=\"pl-c1\"\u003e0\u003c/span\u003e + n = n\n:= \u003cspan class=\"pl-k\"\u003eby\u003c/span\u003e induction n \u003cspan class=\"pl-k\"\u003ewith\u003c/span\u003e\n| zero =\u003e rfl\n| succ n ih =\u003e rw [Nat.add_succ, ih]"},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Looks like some dark magic."}],"id":"op-cuG0T0M8wE"},{"text":""}],"id":"pr-YwO9MLGwG8"},{"type":"p","children":[{"text":"Don’t sweat the details here! You just need to know that if we run the "},{"type":"inlinecode","children":[{"text":"lean"}]},{"text":" program on this file, it derives the statement that "},{"type":"inlinecode","children":[{"text":"(n : Nat) : 0 + n = n"}]},{"text":". We can imagine "},{"type":"inlinecode","children":[{"text":"lean"}]},{"text":" as a function that takes a proof string, and either returns "},{"type":"inlinecode","children":[{"text":"null"}]},{"text":" (meaning the proof string is nonsense), or returns the statement string that it proves. Examples:"}]},{"type":"blockcode","html":"\u003cspan class=\"pl-c\"\u003e// An accepted proof yields a theorem\u003c/span\u003e\n\u003cspan class=\"pl-en\"\u003elean\u003c/span\u003e(\u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003etheorem zero_add ...\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003e\u003c/span\u003e)\n  \u003cspan class=\"pl-k\"\u003e===\u003c/span\u003e \u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003e(n : Nat) : 0 + n = n\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003e\u003c/span\u003e;\n\n\u003cspan class=\"pl-c\"\u003e// A nonsense proof proves nothing\u003c/span\u003e\n\u003cspan class=\"pl-en\"\u003elean\u003c/span\u003e(\u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003enonsense\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003e\u003c/span\u003e) \u003cspan class=\"pl-k\"\u003e===\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003enull\u003c/span\u003e;"},{"type":"p","children":[{"text":"(Note that "},{"type":"inlinecode","children":[{"text":"lean"}]},{"text":" will always halt with either "},{"type":"inlinecode","children":[{"text":"null"}]},{"text":" or a theorem. It just runs the finite list of commands in the proof; it cannot loop forever.)"}]},{"type":"p","children":[{"text":"Now let’s see what makes Lean a ‘formal system.’ A formal system has three things:"}]},{"type":"p","children":[{"text":"A language to make "},{"bold":true,"text":"statements. "},{"text":"In Lean, those are things like "},{"type":"inlinecode","children":[{"text":"(n : Nat) : 0 + n = n"}]},{"text":"."}],"listStyleType":"disc"},{"type":"p","children":[{"text":"A language to make "},{"bold":true,"text":"proofs."},{"text":" In Lean, those are things like "},{"type":"inlinecode","children":[{"text":"theorem zero_add ..."}]},{"text":", which we saw earlier."}],"listStyleType":"disc"},{"type":"p","children":[{"text":"A way to interpret a proof string as a way to generate a proved statement, which we call a "},{"bold":true,"text":"theorem."},{"text":" In the Lean formal system, that’s the program "},{"type":"inlinecode","children":[{"text":"lean"}]},{"text":"."}],"listStyleType":"disc"},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Let’s find more theorems!"}],"id":"op-M4s0phcmXS"},{"text":""}],"id":"pr-O0eXG3iLZb"},{"type":"h2","id":"enumerating-theorems-1234","children":[{"text":"Enumerating theorems ... 🔢"}]},{"type":"p","children":[{"text":"So now the computer can help check our proofs. But "},{"text":"finding","italic":true},{"text":" theorems is still hard work! Can’t we get the computer to prove everything for us? How might we do that?"}]},{"type":"p","children":[{"text":"Here’s an idea ... just list out all the possible strings! Every Lean theorem is just a string, so it must be somewhere in the list of all possible strings! Here’s how we can list all strings, in order of increasing length, using a JavaScript "},{"type":"link","children":[{"text":"generator"}],"href":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*"},{"text":":"}]},{"type":"blockcode","html":"\u003cspan class=\"pl-c\"\u003e// Long list of all Unicode chars!\u003c/span\u003e\n\u003cspan class=\"pl-k\"\u003econst\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003ealphabet\u003c/span\u003e \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003eabc...012...αβγ...\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003e\u003c/span\u003e;\n\n\u003cspan class=\"pl-k\"\u003efunction*\u003c/span\u003e \u003cspan class=\"pl-en\"\u003estrings\u003c/span\u003e() {\n  \u003cspan class=\"pl-k\"\u003eyield\u003c/span\u003e \u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e\"\"\u003c/span\u003e\u003c/span\u003e;\n  \u003cspan class=\"pl-k\"\u003efor\u003c/span\u003e (\u003cspan class=\"pl-k\"\u003econst\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003es\u003c/span\u003e \u003cspan class=\"pl-k\"\u003eof\u003c/span\u003e \u003cspan class=\"pl-en\"\u003estrings\u003c/span\u003e())\n    \u003cspan class=\"pl-k\"\u003efor\u003c/span\u003e (\u003cspan class=\"pl-k\"\u003econst\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003ec\u003c/span\u003e \u003cspan class=\"pl-k\"\u003eof\u003c/span\u003e \u003cspan class=\"pl-smi\"\u003ealphabet\u003c/span\u003e)\n      \u003cspan class=\"pl-k\"\u003eyield\u003c/span\u003e (\u003cspan class=\"pl-smi\"\u003es\u003c/span\u003e \u003cspan class=\"pl-k\"\u003e+\u003c/span\u003e \u003cspan class=\"pl-smi\"\u003ec\u003c/span\u003e);\n}"},{"type":"p","children":[{"text":"This generates strings in length order, shortest first: all 0-char strings, then all 1-char strings, then all 2-char strings, and so on. The list looks like this:"}]},{"type":"blockcode","html":"\u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e\"\"\u003c/span\u003e\u003c/span\u003e, \u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003ea\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003e\u003c/span\u003e, \u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003eb\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003e\u003c/span\u003e, \u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003ec\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003e\u003c/span\u003e, \u003cspan class=\"pl-k\"\u003e...\u003c/span\u003e, \u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003eaa\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003e\u003c/span\u003e, \u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003eab\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003e\u003c/span\u003e, \u003cspan class=\"pl-k\"\u003e...\u003c/span\u003e"},{"type":"p","children":[{"text":"Will the string "},{"type":"inlinecode","children":[{"text":"\"(n : Nat) : 0 + n = n\""}]},{"text":" appear in this list?"}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Yes"}],"id":"op-xxHfFEmKSC","correct":true},{"text":""},{"type":"option","children":[{"text":"No"}],"id":"op-WoYmFpzQTT","correct":false},{"text":""}],"id":"pr-r6FsNuKrqA"},{"type":"response","children":[{"type":"p","children":[{"text":"Right! This specific string will appear somewhere in the block of 21-char strings."}]}],"toPromptId":"pr-r6FsNuKrqA","optionIds":["op-xxHfFEmKSC"]},{"type":"response","children":[{"type":"p","children":[{"text":"Actually, it will appear, but it will take a while. Since the string "},{"type":"inlinecode","children":[{"text":"\"(n : Nat) : 0 + n = n\""}]},{"text":" has 21 characters, it will turn up somewhere in the block of 21-char strings."}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Okay"}],"id":"op-QWcGyDpCtD"},{"text":""}],"id":"pr-XCMNq9Npuh"}],"toPromptId":"pr-r6FsNuKrqA","optionIds":["op-WoYmFpzQTT"]},{"type":"p","children":[{"text":"But now we have a problem. For each string in the list, we want to ask whether it’s a theorem. Can we do that by passing it to the "},{"type":"inlinecode","children":[{"text":"lean"}]},{"text":" program?"}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Yes"}],"id":"op-iz0Xh_LuMo","correct":false},{"text":""},{"type":"option","children":[{"text":"No"}],"id":"op-0kkV01FsyW","correct":true},{"text":""}],"id":"pr-btUSPwY_eN"},{"type":"p","children":[{"text":"The "},{"type":"inlinecode","children":[{"text":"lean"}]},{"text":" program cannot tell us whether a statement is a theorem, because it does not accept "},{"text":"statements","italic":true},{"text":" as input. It accepts "},{"text":"proofs","italic":true},{"text":" as inputs! So instead, we will iterate through all strings, and try to interpret each string as a "},{"text":"proof","italic":true},{"text":":"}]},{"type":"blockcode","html":"\u003cspan class=\"pl-k\"\u003efunction*\u003c/span\u003e \u003cspan class=\"pl-en\"\u003etheorems\u003c/span\u003e() {\n  \u003cspan class=\"pl-k\"\u003efor\u003c/span\u003e (\u003cspan class=\"pl-k\"\u003econst\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003es\u003c/span\u003e \u003cspan class=\"pl-k\"\u003eof\u003c/span\u003e \u003cspan class=\"pl-en\"\u003estrings\u003c/span\u003e()) {\n    \u003cspan class=\"pl-k\"\u003econst\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003et\u003c/span\u003e \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-en\"\u003elean\u003c/span\u003e(\u003cspan class=\"pl-smi\"\u003es\u003c/span\u003e);\n    \u003cspan class=\"pl-k\"\u003eif\u003c/span\u003e (\u003cspan class=\"pl-smi\"\u003et\u003c/span\u003e \u003cspan class=\"pl-k\"\u003e!==\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003enull\u003c/span\u003e) \u003cspan class=\"pl-k\"\u003eyield\u003c/span\u003e \u003cspan class=\"pl-smi\"\u003et\u003c/span\u003e;\n  }\n}"},{"type":"p","children":[{"text":"This procedure "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":" goes through every possible string, and for each, calls "},{"type":"inlinecode","children":[{"text":"lean"}]},{"text":" on it. If "},{"type":"inlinecode","children":[{"text":"lean"}]},{"text":" says the string is a valid proof, it outputs the theorem that it proves."}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"So "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":" lists all the Lean theorems! Cool!"}],"id":"op-wRCP-Nr7ur"},{"text":""}],"id":"pr-UbeXwRTmto"},{"type":"h2","id":"does-theorems-do-what-it-says-on-the-tin","children":[{"text":"Does "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":" do what it says on the tin? 🥫"}]},{"type":"p","children":[{"text":"Before we get too excited, let’s distinguish two things:"}]},{"type":"p","children":[{"text":"The set of strings outputted by "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":""}],"listStyleType":"disc"},{"type":"p","children":[{"text":"The set of strings that are Lean theorems"}],"listStyleType":"disc"},{"type":"p","children":[{"text":"Are these the same sets? Let’s check. First, consider the earlier Lean statement, "},{"type":"inlinecode","children":[{"text":"(n : Nat) : 0 + n = n"}]},{"text":". Will this statement eventually be found by "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":"?"}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Yes, definitely"}],"id":"op-vRMjUrHBde","correct":true},{"text":""},{"type":"option","children":[{"text":"Maybe not"}],"id":"op-Lh7V8b1pHX","correct":false},{"text":""}],"id":"pr-TZaZCzSakq"},{"type":"response","children":[{"type":"p","children":[{"text":"Right: we saw earlier that this statement has a proof that is accepted by Lean. "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":" will eventually find that proof string, then output it."}]}],"toPromptId":"pr-TZaZCzSakq","optionIds":["op-vRMjUrHBde"]},{"type":"response","children":[{"type":"p","children":[{"text":"Actually, it will be found; it will just take a while. We know that this statement has a proof that Lean accepts: "},{"type":"inlinecode","children":[{"text":"theorem zero_add ..."}]},{"text":". That string is 115 characters long. That string will turn up in "},{"type":"inlinecode","children":[{"text":"strings()"}]},{"text":", in the block of all 115-char strings."}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"I see"}],"id":"op-BqBEAPd2nc"},{"text":""}],"id":"pr-b5ApggPVer"}],"toPromptId":"pr-TZaZCzSakq","optionIds":["op-Lh7V8b1pHX"]},{"type":"p","children":[{"text":"Next, consider some string "},{"type":"inlinemath","htmlOrError":"\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.4306em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003ex\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e"},{"text":" outputted by "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":". Is it possible that "},{"type":"inlinemath","htmlOrError":"\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.4306em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003ex\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e"},{"text":" is "},{"text":"not ","italic":true},{"text":"a Lean theorem? Read the source of "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":" to check."}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Yes, "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":" could output a non-theorem!"}],"id":"op--IcuMlM0c0","correct":false},{"text":""},{"type":"option","children":[{"text":"No, "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":" only outputs theorems."}],"id":"op-9B-nvgWK8t","correct":true},{"text":""}],"id":"pr-C4HniZw82O"},{"type":"response","children":[{"type":"p","children":[{"text":"Remember the definition of ‘theorem’: any string that’s returned by "},{"type":"inlinecode","children":[{"text":"lean"}]},{"text":". Check the source: each value outputted by "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":" came from "},{"type":"inlinecode","children":[{"text":"lean"}]},{"text":", so it must be a theorem."}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Okay"}],"id":"op-BACaCldO5e"},{"text":""}],"id":"pr-xEo3nX_932"}],"toPromptId":"pr-C4HniZw82O","optionIds":["op--IcuMlM0c0"]},{"type":"response","children":[{"type":"p","children":[{"text":"Right: "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":" only outputs a string if it has a proof that passes "},{"type":"inlinecode","children":[{"text":"lean"}]},{"text":" — that is to say, it’s a theorem."}]}],"toPromptId":"pr-C4HniZw82O","optionIds":["op-9B-nvgWK8t"]},{"type":"p","children":[{"text":"So, we’ve found that "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":" is indeed one and the same as the set of all theorems! Although, here’s one wrinkle ... let’s say we wait around until the theorem  "},{"type":"inlinecode","children":[{"text":"(n : Nat) : 0 + n = n"}]},{"text":" is outputted by "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":". After that, is it possible that that same theorem could be outputted again?"}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Yes, each theorem could appear many times"}],"id":"op-BMyijKDSZ7","correct":true},{"text":""},{"type":"option","children":[{"text":"No, each theorem appears once"}],"id":"op-NGBcbQR_d7"},{"text":""}],"id":"pr-ZBBORLTx-s"},{"type":"response","children":[{"type":"p","children":[{"text":"Right."}]}],"toPromptId":"pr-ZBBORLTx-s","optionIds":["op-BMyijKDSZ7"]},{"type":"response","children":[{"type":"p","children":[{"text":"Actually, in general, it is possible!"}]}],"toPromptId":"pr-ZBBORLTx-s","optionIds":["op-NGBcbQR_d7"]},{"type":"p","children":[{"text":"A theorem will be outputted once for every possible proof of that theorem. But this turns out to be unimportant; we can just de-duplicate these outputs."}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Right, so the computer can prove everything!"}],"id":"op-SvcaEiA0rT"},{"text":""}],"id":"pr--BLQSz0jrg"},{"type":"p","children":[{"text":"Well ... the computer can generate all the Lean theorems. And that’s really cool! In fact, let’s take a moment to see just how cool it is ..."}]},{"type":"paywall","children":[{"text":""}]},{"type":"h2","id":"statements-about-programs","children":[{"text":"Statements about programs! 👩‍💻"}]},{"type":"p","children":[{"text":"Statements like “"},{"type":"inlinemath","htmlOrError":"\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003ex\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222em;\"\u003e\u003c/span\u003e\u003cspan class=\"mbin\"\u003e+\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.6444em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e0\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2778em;\"\u003e\u003c/span\u003e\u003cspan class=\"mrel\"\u003e=\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2778em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.4306em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003ex\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e"},{"text":"” seem a bit dull. Is Lean limited to arithmetic, or can it tackle more interesting math? In "},{"type":"link","children":[{"text":"the previous chapter"}],"href":"https://tigyog.app/d/fr9uub3hqgab/r/the-halting-problem"},{"text":", we learned about the halting problem. That topic is surely mathematics! So can we ‘formalize’ it in Lean?"}]},{"type":"p","children":[{"text":"It turns out, yes! We can teach Lean a simple language called the "},{"type":"link","children":[{"bold":true,"text":"Turing Machine"}],"href":"https://github.com/leanprover-community/mathlib/blob/8f9520eb24f83056021ccea9d1181508a999e46e/src/computability/turing_machine.lean#L871"},{"text":", and teach it "},{"type":"link","children":[{"text":"how to run one"}],"href":"https://github.com/leanprover-community/mathlib/blob/8f9520eb24f83056021ccea9d1181508a999e46e/src/computability/turing_machine.lean#L888"},{"text":". Then we can talk about whether a Turing Machine machine eventually halts. And "},{"type":"link","children":[{"text":"here it is: a Lean (v3) proof of Turing’s theorem!"}],"href":"https://leanprover-community.github.io/mathlib_docs/computability/halting.html#computable_pred.halting_problem"},{"text":":"}]},{"type":"blockcode","html":"\u003cspan class=\"pl-k\"\u003etheorem\u003c/span\u003e \u003cspan class=\"pl-en\"\u003ehalting_problem\u003c/span\u003e (n) :\n  ¬ computable_pred (\u003cspan class=\"pl-k\"\u003eλ\u003c/span\u003e c, (eval c n).dom)\n  | h :=\n  rice {f | (f n).dom} h nat.partrec.zero\n  nat.partrec.none trivial"},{"type":"p","children":[{"text":"So Lean can prove that the halting problem is undecidable. But if you run "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":", will it discover this theorem?"}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Yes"}],"id":"op-brAhyLOd9h","correct":true},{"text":""},{"type":"option","children":[{"text":"No"}],"id":"op-ST_cGKT1NH","correct":false},{"text":""}],"id":"pr-UxPQRS-0nJ"},{"type":"response","children":[{"type":"p","children":[{"text":"Right: "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":" really does find "},{"text":"every","italic":true},{"text":" theorem!"}]}],"toPromptId":"pr-UxPQRS-0nJ","optionIds":["op-brAhyLOd9h"]},{"type":"response","children":[{"type":"p","children":[{"text":"Remember: "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":" really does work! Since there is a Lean proof of Turing’s theorem, "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":" will eventually find it, then output the theorem."}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Okay"}],"id":"op-FjHCvUCm4-"},{"text":""}],"id":"pr-AnYXA8q6EN"}],"toPromptId":"pr-UxPQRS-0nJ","optionIds":["op-ST_cGKT1NH"]},{"type":"p","children":[{"text":"And not only that: "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":" will find the shortest proof. Perhaps it’s much more elegant than the one we humans found. So, "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":" really is amazing! Let’s try it out, and see if we can win ourselves a mathematical prize!"}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Continue"}],"id":"op--bqVsGz0Ty"},{"text":""}],"id":"pr-1yLX9JWXp1"},{"type":"h2","id":"theorem-mining-better-than-crypto","children":[{"text":"Theorem mining — better than crypto?"}]},{"type":"p","children":[{"text":"Instead of just listing out "},{"text":"all","italic":true},{"text":" theorems, let’s say we’re just interested in one particular mathematical claim, and we want to know whether it’s true. Consider the following famous function:"}]},{"type":"blockcode","html":"\u003cspan class=\"pl-k\"\u003efunction\u003c/span\u003e \u003cspan class=\"pl-en\"\u003ecollatz\u003c/span\u003e(\u003cspan class=\"pl-v\"\u003en\u003c/span\u003e\u003cspan class=\"pl-k\"\u003e:\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003enumber\u003c/span\u003e) {\n  \u003cspan class=\"pl-k\"\u003ewhile\u003c/span\u003e (\u003cspan class=\"pl-smi\"\u003en\u003c/span\u003e \u003cspan class=\"pl-k\"\u003e!=\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e1\u003c/span\u003e) {\n    \u003cspan class=\"pl-k\"\u003eif\u003c/span\u003e (\u003cspan class=\"pl-smi\"\u003en\u003c/span\u003e \u003cspan class=\"pl-k\"\u003e%\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e2\u003c/span\u003e \u003cspan class=\"pl-k\"\u003e==\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e0\u003c/span\u003e) \u003cspan class=\"pl-smi\"\u003en\u003c/span\u003e \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-smi\"\u003en\u003c/span\u003e \u003cspan class=\"pl-k\"\u003e/\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e2\u003c/span\u003e;\n    \u003cspan class=\"pl-k\"\u003eelse\u003c/span\u003e \u003cspan class=\"pl-smi\"\u003en\u003c/span\u003e \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e3\u003c/span\u003e\u003cspan class=\"pl-k\"\u003e*\u003c/span\u003e\u003cspan class=\"pl-smi\"\u003en\u003c/span\u003e \u003cspan class=\"pl-k\"\u003e+\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e1\u003c/span\u003e;\n  }\n}"},{"type":"p","children":[{"text":"Try it out! Does "},{"type":"inlinecode","children":[{"text":"collatz(3)"}]},{"text":" halt?"}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Yes"}],"id":"op-WVsqQZrgeo","correct":true},{"text":""},{"type":"option","children":[{"text":"No"}],"id":"op-WfyWXaxCmc","correct":false},{"text":""}],"id":"pr-s09KgNpUw2"},{"type":"response","children":[{"type":"p","children":[{"text":"Actually, it halts after the following steps:"}]},{"type":"blockcode","html":"n = 3. Odd, so triple it and add 1.\nn = 10. Even, so halve it.\nn = 5. Odd, so triple it and add 1.\nn = 16. Even, so halve it.\nn = 8. Even, so halve it.\nn = 4. Even, so halve it.\nn = 2. Even, so halve it.\nn = 1. Halt!"},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Okay"}],"id":"op-yLiZtTQ9jS"},{"text":""}],"id":"pr-N2O3fihQP4"}],"toPromptId":"pr-s09KgNpUw2","optionIds":["op-WfyWXaxCmc"]},{"type":"p","children":[{"text":"Okay, now what about for any starting number? In 1937, "},{"type":"link","children":[{"text":"Herr Collatz"}],"href":"https://en.wikipedia.org/wiki/Lothar_Collatz"},{"text":" himself conjectured: “"},{"type":"inlinecode","children":[{"text":"collatz(n)"}]},{"text":" always halts, for every natural number "},{"type":"inlinecode","children":[{"text":"n"}]},{"text":".” What do you think of this claim?"}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"True!"}],"id":"op-SqQo0xXW-C"},{"text":""},{"type":"option","children":[{"text":"False!"}],"id":"op-i7rvkjUMDX"},{"text":""},{"type":"option","children":[{"text":"Neither true nor false!"}],"id":"op-e7waspABRf","correct":false},{"text":""},{"type":"option","children":[{"text":"I don’t know!"}],"id":"op-5k-_UaUDqj"},{"text":""}],"id":"pr-k9xoym0KXX"},{"type":"response","children":[{"type":"p","children":[{"text":"Well, Wikipedia says that "},{"type":"link","children":[{"text":"nobody knows"}],"href":"https://en.wikipedia.org/wiki/Collatz_conjecture"},{"text":"! If you genuinely have a proof, then glory and power awaits you! But my point is, the claim is either true or false."}]}],"toPromptId":"pr-k9xoym0KXX","optionIds":["op-SqQo0xXW-C","op-i7rvkjUMDX"]},{"type":"response","children":[{"type":"p","children":[{"text":"That’s an interesting philosophical position! I disagree, though. Collatz’s claim seems well-defined, a bit like “all natural numbers "},{"type":"inlinemath","htmlOrError":"\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.4306em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord mathnormal\"\u003en\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e"},{"text":" are either even or odd.” Imagine someone tomorrow revealed a genuine proof that the claim is true. Surely then it’s also true right now, even though we don’t know it yet?"}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Okay, I accept that it’s either true or false."}],"id":"op-3qI891ynXo"},{"text":""}],"id":"pr-Bi_CtnwLuj"}],"toPromptId":"pr-k9xoym0KXX","optionIds":["op-e7waspABRf"]},{"type":"response","children":[{"type":"p","children":[{"text":"Don’t worry, "},{"type":"link","children":[{"text":"nobody else knows either"}],"href":"https://en.wikipedia.org/wiki/Collatz_conjecture"},{"text":"! The point is, the claim is either true or false."}]}],"toPromptId":"pr-k9xoym0KXX","optionIds":["op-5k-_UaUDqj"]},{"type":"p","children":[{"text":"There’s "},{"type":"link","children":[{"text":"a $1M prize"}],"href":"https://mathprize.net/posts/collatz-conjecture/"},{"text":" for proving the truth or non-truth of this famous conjecture. So let’s deploy our amazing function "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":" to earn some easy money! First, we write the conjecture in Lean:"}]},{"type":"blockcode","html":"\u003cspan class=\"pl-k\"\u003eimport\u003c/span\u003e Init.Data.Nat.Basic\n\n\u003cspan class=\"pl-k\"\u003edef\u003c/span\u003e \u003cspan class=\"pl-en\"\u003estep\u003c/span\u003e (n: Nat): Nat :=\n  \u003cspan class=\"pl-k\"\u003eif\u003c/span\u003e n%\u003cspan class=\"pl-c1\"\u003e2\u003c/span\u003e == \u003cspan class=\"pl-c1\"\u003e0\u003c/span\u003e \u003cspan class=\"pl-k\"\u003ethen\u003c/span\u003e n/\u003cspan class=\"pl-c1\"\u003e2\u003c/span\u003e \u003cspan class=\"pl-k\"\u003eelse\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003e3\u003c/span\u003e*n + \u003cspan class=\"pl-c1\"\u003e1\u003c/span\u003e\n\n\u003cspan class=\"pl-k\"\u003edef\u003c/span\u003e \u003cspan class=\"pl-en\"\u003ecoll_conj\u003c/span\u003e :=\n  ∀n, n\u003e\u003cspan class=\"pl-c1\"\u003e0\u003c/span\u003e -\u003e ∃s,\n    Nat.repeat step s n = \u003cspan class=\"pl-c1\"\u003e1\u003c/span\u003e"},{"type":"p","children":[{"text":"Then we search through "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":" to see whether there’s a proof:"}]},{"type":"blockcode","html":"\u003cspan class=\"pl-k\"\u003econst\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003ecoll_conj\u003c/span\u003e \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003e...\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003e\u003c/span\u003e;\n\n\u003cspan class=\"pl-k\"\u003efunction\u003c/span\u003e \u003cspan class=\"pl-en\"\u003eis_collatz_true\u003c/span\u003e() {\n  \u003cspan class=\"pl-k\"\u003efor\u003c/span\u003e (\u003cspan class=\"pl-k\"\u003econst\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003et\u003c/span\u003e \u003cspan class=\"pl-k\"\u003eof\u003c/span\u003e \u003cspan class=\"pl-en\"\u003etheorems\u003c/span\u003e()) {\n    \u003cspan class=\"pl-k\"\u003eif\u003c/span\u003e (\u003cspan class=\"pl-smi\"\u003et\u003c/span\u003e \u003cspan class=\"pl-k\"\u003e===\u003c/span\u003e \u003cspan class=\"pl-smi\"\u003ecoll_conj\u003c/span\u003e) {\n      \u003cspan class=\"pl-c\"\u003e// Proof found! It must be true!\u003c/span\u003e\n      \u003cspan class=\"pl-k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003etrue\u003c/span\u003e;\n    }\n  }\n\n  \u003cspan class=\"pl-c\"\u003e// No proof found! It must be false!\u003c/span\u003e\n  \u003cspan class=\"pl-k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003efalse\u003c/span\u003e;\n}"},{"type":"p","children":[{"text":"Here’s how it should work: if the conjecture is true, "},{"type":"inlinecode","children":[{"text":"is_collatz_true"}]},{"text":" should return "},{"type":"inlinecode","children":[{"text":"true"}]},{"text":", and if the conjecture is false, "},{"type":"inlinecode","children":[{"text":"is_collatz_true"}]},{"text":" should return "},{"type":"inlinecode","children":[{"text":"false"}]},{"text":"."}]},{"type":"p","children":[{"text":"Now, imagine that the Collatz conjecture is false. Read the source: what does "},{"type":"inlinecode","children":[{"text":"is_collatz_true"}]},{"text":" do in this case?"}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Return "},{"type":"inlinecode","children":[{"text":"true"}]},{"text":""}],"id":"op-v3in_VxWm3"},{"text":""},{"type":"option","children":[{"text":"Return "},{"type":"inlinecode","children":[{"text":"false"}]},{"text":""}],"id":"op-cS8d1ebGxy","correct":false},{"text":""},{"type":"option","children":[{"text":"Loop forever"}],"id":"op-KFqUFJ3lMG","correct":true},{"text":""}],"id":"pr-bOwqC8tvmD"},{"type":"response","children":[{"type":"p","children":[{"text":"Interesting. You seem to be saying that Lean has a proof that the conjecture is true, even though it’s false! And actually, that’s possible, and we’ll talk about that in a few minutes! But for now, let’s assume Lean is not "},{"text":"that","italic":true},{"text":" broken."}]},{"type":"p","children":[{"text":"Remember that "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":" searches the infinite list of all strings for proofs. Assuming the Collatz conjecture is false, and Lean is not broken, it should never find a valid proof of the conjecture. It will keep searching forever, so the loop will never finish, and "},{"type":"inlinecode","children":[{"text":"is_collatz_true"}]},{"text":" will never return."}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Okay"}],"id":"op-UPAJUlEldT"},{"text":""}],"id":"pr--Bgvw-TFRd"}],"toPromptId":"pr-bOwqC8tvmD","optionIds":["op-v3in_VxWm3"]},{"type":"response","children":[{"type":"p","children":[{"text":"Remember that "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":" searches the infinite list of all strings. It will keep searching forever, so the loop will never finish, so "},{"type":"inlinecode","children":[{"text":"is_collatz_true"}]},{"text":" will never reach the "},{"type":"inlinecode","children":[{"text":"return false"}]},{"text":" line."}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Okay"}],"id":"op-MTst4xUwiW"},{"text":""}],"id":"pr-bz3jmA3SC6"}],"toPromptId":"pr-bOwqC8tvmD","optionIds":["op-cS8d1ebGxy"]},{"type":"p","children":[{"text":"The problem is that we never actually search for a proof that the conjecture is false; we only search for a proof that it’s true!"}]},{"type":"p","children":[{"text":"In Lean, the word ‘not’ is written as "},{"type":"inlinecode","children":[{"text":"¬"}]},{"text":". So the inverse of the conjecture is "},{"type":"inlinecode","children":[{"text":"¬coll_conj"}]},{"text":". So let’s just add that to our search!"}]},{"type":"blockcode","html":"\u003cspan class=\"pl-k\"\u003efunction\u003c/span\u003e \u003cspan class=\"pl-en\"\u003eis_stmt_true\u003c/span\u003e(\u003cspan class=\"pl-v\"\u003es\u003c/span\u003e\u003cspan class=\"pl-k\"\u003e:\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003estring\u003c/span\u003e) {\n  \u003cspan class=\"pl-k\"\u003efor\u003c/span\u003e (\u003cspan class=\"pl-k\"\u003econst\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003et\u003c/span\u003e \u003cspan class=\"pl-k\"\u003eof\u003c/span\u003e \u003cspan class=\"pl-en\"\u003etheorems\u003c/span\u003e()) {\n    \u003cspan class=\"pl-k\"\u003eif\u003c/span\u003e (\u003cspan class=\"pl-smi\"\u003et\u003c/span\u003e \u003cspan class=\"pl-k\"\u003e==\u003c/span\u003e \u003cspan class=\"pl-smi\"\u003es\u003c/span\u003e) \u003cspan class=\"pl-k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003etrue\u003c/span\u003e;\n    \u003cspan class=\"pl-k\"\u003eif\u003c/span\u003e (\u003cspan class=\"pl-smi\"\u003et\u003c/span\u003e \u003cspan class=\"pl-k\"\u003e==\u003c/span\u003e \u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003e¬\u003cspan class=\"pl-pds\"\u003e\"\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"pl-k\"\u003e+\u003c/span\u003e\u003cspan class=\"pl-smi\"\u003es\u003c/span\u003e) \u003cspan class=\"pl-k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003efalse\u003c/span\u003e;\n  }\n}\n\n\u003cspan class=\"pl-k\"\u003efunction\u003c/span\u003e \u003cspan class=\"pl-en\"\u003eis_collatz_true\u003c/span\u003e() {\n  \u003cspan class=\"pl-k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"pl-en\"\u003eis_stmt_true\u003c/span\u003e(\u003cspan class=\"pl-smi\"\u003ecoll_conj\u003c/span\u003e);\n}"},{"type":"p","children":[{"text":"This is looking better! We have an amazing function, "},{"type":"inlinecode","children":[{"text":"is_stmt_true"}]},{"text":", that can tell us whether anything is true or false, given enough time!"}]},{"type":"p","children":[{"text":"Read it through, and try to prove to yourself that "},{"type":"inlinecode","children":[{"text":"is_collatz_true"}]},{"text":" really does eventually return the truth of the Collatz conjecture."}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Okay, I tried to prove it ..."}],"id":"op-O92GNVkgJk"},{"text":""}],"id":"pr-bi0Erwim75"},{"type":"p","children":[{"text":"Eventually, I think you’ll realize the algorithm relies on this assumption:  “"},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":" contains "},{"bold":true,"text":"either"},{"text":" "},{"type":"inlinecode","children":[{"text":"coll_conj"}]},{"text":" "},{"bold":true,"text":"or"},{"text":" "},{"type":"inlinecode","children":[{"text":"¬coll_conj"}]},{"text":". It does not contain both, or neither.”"}]},{"type":"p","children":[{"text":"This assumption is quite natural. We’ve already accepted that the Collatz conjecture is either true or false. So, similarly, "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":" should contain either "},{"type":"inlinecode","children":[{"text":"coll_conj"}]},{"text":" or "},{"type":"inlinecode","children":[{"text":"¬coll_conj"}]},{"text":". This gets to the heart of what Godel wanted to prove."}]},{"type":"h2","id":"consistency","children":[{"text":"Consistency 👎👍"}]},{"type":"p","children":[{"text":"But what if "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":" contains "},{"text":"both","italic":true},{"text":" "},{"type":"inlinecode","children":[{"text":"coll_conj"}]},{"text":" "},{"text":"and","italic":true},{"text":" "},{"type":"inlinecode","children":[{"text":"¬coll_conj"}]},{"text":"? Is that possible?"}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Yes"}],"id":"op-L3eyjNJoct"},{"text":""},{"type":"option","children":[{"text":"No"}],"id":"op-1cWogHiw8r"},{"text":""},{"type":"option","children":[{"text":"I don’t know"}],"id":"op-y1c5k6TzOu","correct":true},{"text":""}],"id":"pr-oFxPwW-3NU"},{"type":"response","children":[{"type":"p","children":[{"text":"That’s a reasonable answer: maybe Lean’s rules allow for this! Although if you know of an example, you should file a bug report with the Lean developers. 😉"}]}],"toPromptId":"pr-oFxPwW-3NU","optionIds":["op-L3eyjNJoct"]},{"type":"response","children":[{"type":"p","children":[{"text":"You must really trust Lean! And you’re not alone: people working with formal systems generally assume that this can’t happen. But in general, a formal system can have both "},{"type":"inlinecode","children":[{"text":"S"}]},{"text":" and "},{"type":"inlinecode","children":[{"text":"¬S"}]},{"text":" as theorems. It really just depends on the proof rules that they allow."}]}],"toPromptId":"pr-oFxPwW-3NU","optionIds":["op-1cWogHiw8r"]},{"type":"response","children":[{"type":"p","children":[{"text":"Me neither! Really, it depends on the rules of Lean. If we trust Lean, it shouldn’t be possible. But in general, formal systems can have both "},{"type":"inlinecode","children":[{"text":"S"}]},{"text":" and "},{"type":"inlinecode","children":[{"text":"¬S"}]},{"text":" as theorems. It really just depends on the proof rules that they allow."}]}],"toPromptId":"pr-oFxPwW-3NU","optionIds":["op-y1c5k6TzOu"]},{"type":"p","children":[{"text":"This property is known as "},{"bold":true,"text":"consistency."},{"text":" Lean is ‘consistent’ if there are no statements "},{"type":"inlinecode","children":[{"text":"S"}]},{"text":" where both "},{"type":"inlinecode","children":[{"text":"S"}]},{"text":" and "},{"type":"inlinecode","children":[{"text":"¬S"}]},{"text":" are theorems."}]},{"type":"p","children":[{"text":"Recall the ‘proof by contradiction’ method that we used in Chapter 1 to prove Turing’s theorem. The idea is that, if an assumption leads to a contradiction, the assumption must be false. The Lean system lets you use this proof method to generate theorems."}]},{"type":"p","children":[{"text":"Now, imagine that both "},{"type":"inlinecode","children":[{"text":"coll_conj"}]},{"text":" and "},{"type":"inlinecode","children":[{"text":"¬coll_conj"}]},{"text":" are both theorems. Could we prove that "},{"type":"inlinecode","children":[{"text":"1+1=3"}]},{"text":" in Lean?"}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Yes"}],"id":"op-IzUS55fhoh","correct":true},{"text":""},{"type":"option","children":[{"text":"No"}],"id":"op-20msdIF-EC","correct":false},{"text":""},{"type":"option","children":[{"text":"I don’t know"}],"id":"op-slftmL5Q8g"},{"text":""}],"id":"pr-Anm-v3p-E_"},{"type":"response","children":[{"type":"p","children":[{"text":"Right! Even though "},{"type":"inlinemath","htmlOrError":"\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e1\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222em;\"\u003e\u003c/span\u003e\u003cspan class=\"mbin\"\u003e+\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.6444em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e1\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2778em;\"\u003e\u003c/span\u003e\u003cspan class=\"mrel\"\u003e=\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2778em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.6444em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e3\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e"},{"text":" is surely false, we could prove it in Lean using a proof by contradiction: “Let’s assume that "},{"type":"inlinecode","children":[{"text":"¬(1+1=3)"}]},{"text":". But this leads to a contradiction: "},{"type":"inlinecode","children":[{"text":"coll_conj"}]},{"text":" and "},{"type":"inlinecode","children":[{"text":"¬coll_conj"}]},{"text":". We can therefore deduce that our assumption must be false, so "},{"type":"inlinecode","children":[{"text":"1+1=3"}]},{"text":".”"}]}],"toPromptId":"pr-Anm-v3p-E_","optionIds":["op-IzUS55fhoh"]},{"type":"response","children":[{"type":"p","children":[{"text":"So, even though "},{"type":"inlinemath","htmlOrError":"\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e1\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222em;\"\u003e\u003c/span\u003e\u003cspan class=\"mbin\"\u003e+\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2222em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.6444em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e1\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2778em;\"\u003e\u003c/span\u003e\u003cspan class=\"mrel\"\u003e=\u003c/span\u003e\u003cspan class=\"mspace\" style=\"margin-right:0.2778em;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"base\"\u003e\u003cspan class=\"strut\" style=\"height:0.6444em;\"\u003e\u003c/span\u003e\u003cspan class=\"mord\"\u003e3\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e"},{"text":" is surely false, we could prove it in Lean like so: “Let’s assume that "},{"type":"inlinecode","children":[{"text":"¬(1+1=3)"}]},{"text":". But this leads to a contradiction: "},{"type":"inlinecode","children":[{"text":"coll_conj"}]},{"text":" and "},{"type":"inlinecode","children":[{"text":"¬coll_conj"}]},{"text":". We can therefore deduce that our assumption must be false, so "},{"type":"inlinecode","children":[{"text":"1+1=3"}]},{"text":".”"}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"I see."}],"id":"op-dy4CXDheun"},{"text":""}],"id":"pr-mS-oZbWTlI"}],"toPromptId":"pr-Anm-v3p-E_","optionIds":["op-20msdIF-EC","op-slftmL5Q8g"]},{"type":"p","children":[{"text":"Worse, we could use this method to prove "},{"text":"anything","italic":true},{"text":" in Lean! So, inconsistency would be "},{"bold":true,"text":"disastrous. "},{"text":"Mathematicians generally assume that their systems are consistent. (But it turns out to be rather hard to show it! We’ll see why in a future chapter!)"}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Continue"}],"id":"op-ONdTSgj-4i"},{"text":""}],"id":"pr-7UgUKxVWjv"},{"type":"h2","id":"completeness","children":[{"text":"Completeness"}]},{"type":"p","children":[{"text":"This leaves one final possibility. What if "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":" contains "},{"text":"neither","italic":true},{"text":" "},{"type":"inlinecode","children":[{"text":"coll_conj"}]},{"text":" "},{"text":"nor","italic":true},{"text":" "},{"type":"inlinecode","children":[{"text":"¬coll_conj"}]},{"text":"? How disastrous would that be? Could you use that to prove that "},{"type":"inlinecode","children":[{"text":"1+1=3"}]},{"text":" in Lean?"}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Yes"}],"id":"op-og1Oy_jF1p","correct":false},{"text":""},{"type":"option","children":[{"text":"No"}],"id":"op-ereRH1jKCZ","correct":true},{"text":""},{"type":"option","children":[{"text":"I don’t know"}],"id":"op-A9ito0Ms-Z"},{"text":""}],"id":"pr-rg_gR36DIZ"},{"type":"response","children":[{"type":"p","children":[{"text":"If you know how, let me know! "}]}],"toPromptId":"pr-rg_gR36DIZ","optionIds":["op-og1Oy_jF1p"]},{"type":"response","children":[{"type":"p","children":[{"text":"I don’t think so either. At least, the proof by contradiction method can’t apply, since we don’t have a contradiction to work with."}]}],"toPromptId":"pr-rg_gR36DIZ","optionIds":["op-ereRH1jKCZ"]},{"type":"response","children":[{"type":"p","children":[{"text":"That’s fine. I don’t quite know either. the proof by contradiction method can’t apply, since we don’t have a contradiction to work with."}]}],"toPromptId":"pr-rg_gR36DIZ","optionIds":["op-A9ito0Ms-Z"]},{"type":"p","children":[{"text":"In general, the absence of a proof doesn’t lead to a complete collapse. It would just mean that Lean is not powerful enough to comment on the truth of the statement."}]},{"type":"p","children":[{"text":"However, it would still be extremely nice if Lean were able to say, one way or another, whether the Collatz conjecture is true. And it would be even nicer if Lean were able to say, one way or the other, whether "},{"text":"any","italic":true},{"text":" statement is true."}]},{"type":"p","children":[{"text":"If this were the case, we would say that Lean is "},{"bold":true,"text":"complete."},{"text":" Precisely: if Lean is complete, then we can make any statement "},{"type":"inlinecode","children":[{"text":"S"}]},{"text":", and either "},{"type":"inlinecode","children":[{"text":"S"}]},{"text":" or "},{"type":"inlinecode","children":[{"text":"¬S"}]},{"text":" is in "},{"type":"inlinecode","children":[{"text":"theorems()"}]},{"text":"."}]},{"type":"p","children":[{"text":"So, earlier when we tried to prove that "},{"type":"inlinecode","children":[{"text":"is_stmt_true"}]},{"text":" is a correct algorithm, we relied on the assumption that Lean is both consistent and complete."}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Okay, so, is that assumption true?"}],"id":"op-3R8nrq54E7"},{"text":""}],"id":"pr-9Qnbi1bWV8"},{"type":"h2","id":"a-proof-using-turing-s-theorem","children":[{"text":"A proof using Turing’s theorem"}]},{"type":"p","children":[{"text":"So, is Lean consistent and complete? Here’s Gödel’s famous answer: "},{"bold":true,"text":"No, Lean is either inconsistent or incomplete!"}]},{"type":"p","children":[{"text":"Our proof works by way of contradiction. The assumption: "},{"text":"Lean is consistent and complete","italic":true},{"text":". We decided earlier that, if this is true, then our "},{"type":"inlinecode","children":[{"text":"is_stmt_true"}]},{"text":" function works perfectly."}]},{"type":"p","children":[{"text":"Now, recall "},{"type":"link","children":[{"text":"the Halting Problem from the previous chapter"}],"href":"https://busy-beavers.tigyog.app/the-halting-problem"},{"text":". This problem asks for a function "},{"type":"inlinecode","children":[{"text":"halts(tm)"}]},{"text":" that returns "},{"type":"inlinecode","children":[{"text":"true"}]},{"text":" or "},{"type":"inlinecode","children":[{"text":"false"}]},{"text":" telling us whether the Turing Machine "},{"type":"inlinecode","children":[{"text":"tm"}]},{"text":" halts. With our "},{"type":"inlinecode","children":[{"text":"is_stmt_true"}]},{"text":" function, we can easily solve the Halting Problem!:"}]},{"type":"blockcode","html":"\u003cspan class=\"pl-k\"\u003efunction\u003c/span\u003e \u003cspan class=\"pl-en\"\u003ehalts\u003c/span\u003e(\u003cspan class=\"pl-v\"\u003etm\u003c/span\u003e\u003cspan class=\"pl-k\"\u003e:\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003estring\u003c/span\u003e) {\n  \u003cspan class=\"pl-k\"\u003econst\u003c/span\u003e \u003cspan class=\"pl-c1\"\u003elean_stmt\u003c/span\u003e \u003cspan class=\"pl-k\"\u003e=\u003c/span\u003e \u003cspan class=\"pl-s\"\u003e\u003cspan class=\"pl-pds\"\u003e`\u003c/span\u003ehalts ${\u003cspan class=\"pl-smi\"\u003etm\u003c/span\u003e}\u003cspan class=\"pl-pds\"\u003e`\u003c/span\u003e\u003c/span\u003e;\n  \u003cspan class=\"pl-k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"pl-en\"\u003eis_stmt_true\u003c/span\u003e(\u003cspan class=\"pl-smi\"\u003elean_stmt\u003c/span\u003e);\n}"},{"type":"p","children":[{"text":"We saw earlier that Lean can talk about whether Turing Machines halt. So we can construct a Lean statement claiming that the Turing Machine "},{"type":"inlinecode","children":[{"text":"tm"}]},{"text":" halts. Then we just ... ask whether that statement is true!"}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Easy! But hang on ..."}],"id":"op-MNlRYVVLJ0"},{"text":""}],"id":"pr-0SYVvh63uT"},{"type":"p","children":[{"text":"Yes! We also learned in Chapter 1 that the Halting Problem is impossible to solve! So we got a contradiction!"}]},{"type":"p","children":[{"text":"The problem must be our initial assumption, that “Lean is consistent and complete.” We can therefore conclude that "},{"bold":true,"text":"Lean is either inconsistent or incomplete!"}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Okay, that’s Lean. What about other systems?"}],"id":"op-DS6N9UPkdF"},{"text":""}],"id":"pr-puBPdsiIyA"},{"type":"h2","id":"what-about-other-formal-systems","children":[{"text":"What about other formal systems?"}]},{"type":"p","children":[{"text":"In this chapter, we applied this reasoning to Lean, one specific formal system. But the same reasoning can be applied to any formal system F, with fairly minimal assumptions:"}]},{"type":"p","children":[{"text":"1. F is enumerable. (This comes for free via the "},{"type":"inlinecode","children":[{"text":"theorems"}]},{"text":" trick.)"}]},{"type":"p","children":[{"text":"2. We can reason about programs and halting in F."}]},{"type":"p","children":[{"text":"Gödel’s original proof was slightly stronger: it only required that F can reason about arithmetic, rather than programs and halting. But it turns out that pretty much any formal system can reason about programs — we’ll learn how easily in a future chapter!"}]},{"type":"h2","id":"conclusion","children":[{"text":"Conclusion"}]},{"type":"p","children":[{"text":"You might be wondering ... Okay, perhaps we can’t show that our systems of logic are complete, but perhaps we can at least show that they are consistent. But Gödel has some more bad news for you, coming up in the next chapter ..."}]},{"type":"prompt","children":[{"text":""},{"type":"option","children":[{"text":"Finish chapter! 🥸"}],"id":"op-BozvWMkm1c"},{"text":""}],"id":"pr-gO9xwgsQNU"},{"type":"p","children":[{"bold":true,"text":"If you want to know when the next chapter comes out, "},{"type":"link","children":[{"bold":true,"text":"sign up for updates here!"}],"href":"https://tigyog.app/d/C:tWWwvJDWlo/enrollment"},{"bold":true,"text":" You might also enjoy our course "},{"type":"link","children":[{"bold":true,"text":"Everyday Data Science","italic":true}],"href":"https://tigyog.app/d/C-I1weB9CpTH/r/everyday-data-science"},{"bold":true,"text":", which teaches fundamental data science using the same interactive format."}]}]}},"__N_SSP":true},"page":"/_sites/[courseSlug]/[lessonSlug]","query":{"courseSlug":"busy-beavers","lessonSlug":"incompleteness"},"buildId":"WIBuqvvC0gPBScgpprxWY","isFallback":false,"gssp":true,"scriptLoader":[]}          if (window.navigator && window.navigator.serviceWorker) {            window.navigator.serviceWorker.register('/service-worker.js', { scope: '/' });          }          